### 1、类与对象
* 创建对象时，它会被存放在称为堆的内存区域中，它是可回收垃圾的堆，当某个对象被java虚拟机识别不会在使用时，该对象就会呗标记为可回收，当内存不够使用，就会开启回收机制，让空间能够被再次使用。

### 2、primitive主数据类型和引用
* primitive数据类型：byte-8；short-16；int-32；long-64；float-32；double-64；boolean-虚拟机决定；char-16
* 命名规则：名称必须以字母，下划线和$开头，不能以数字开头
* 对象的引用：Dog mydog = new Dog()：Dog mydog声明一个引用变量；new Dog在堆中创建对象；=引用变量连接对象（类似指针）
* 数组也是对象，在堆中创建的对象里面可以是primitive，也可以是声明的引用变量，当是声明的引用变量时可以连接对象。
### 3、方法操作实例变量
* 在往方法传参数时是通过复制传的，如果是primitive类型，在对形参修改不会对原参数更改，而传对象的引用变量是复制的引用变量，所以指向的是同一个对象。当对引用变量修改时会指向新的对象。
* 封装：将属性隐藏，若要访问要通过方法，我们可以控制方法来对属性操作加以限制。
* 实例变量都是有默认值的，但局部变量没有默认值
* 使用==来比较两个primitive主数据类型或者判断两个引用变量是否引用同一个对象，equal比较两个对象是否意义上相等。
### 4、编写程序
* 极限编程（书？？？）
### 5、认识java的API
* javax的包是Sun所认可的java标准扩展包
* 除了java.lang外其他类都需要指定包全名
* *import不同于c的include，不会使程序变大
### 6、继承与多态
* 集成概念下的is-a是一个单向关系，要在父类基础上进行扩展时，可以用super来指代父类。
* 运用多态时，引用变量类型可以是创建对象的父类。
* 重载：只是指相同方法名的不同方法，它根据参数不同来区分，它与重载与多态没有关系。
### 7、接口与抽象类（深入多态）
* 抽象类是不能被实例化的类，可以用于定义引用变量类型给多态使用。抽象类除了被继承外，是没有用途，没有值，没有目的的。
* 抽象的方法是没有实体的，不能在非抽象类中有抽象方法。抽象类被具体类继承后，里面的抽象方法是必须实现的。如果抽象类继承就不用一定实现抽象方法。
* 编译器是根据引用变量类型来判断能够执行的方法，而不是根据Object确定的类型。可通过强制类型来转换object。
* 不允许多重继承，多重继承会造成 ***致命方块*** 问题，即两个父类有同一个实现方法，那子类继承哪一个？？？
* 接口就是为了解决不能多重继承问题，即让方法都抽象化，使子类必须实现，从而解决 ***致命方块*** 问题。接口就是百分比抽象类。
# 8、构造器与垃圾收集器
* 栈与堆：对象的生存空间堆（heap）和方法调用和变量的生存空间栈（stack）
* 对象局部变量：对象会在堆中，而引用变量会在栈中。
* 构造函数：是你初始化对象之前会执行的代码。如果你有一个自己编写的有参数的构造函数，如果你需要没有参数的构造函数，则你必须自己编写。
* 构造函数会自动调用super(),即使没写也会在方法最开始执行。
* 对象的生命周期：对象的生命根据引用变量决定，实例变量的生命周期由对象决定。
* 局部变量只有方法在栈顶时才能使用。
### 9、数字与静态
* Math这个类中所有方法都是静态（static）的，所以无需堆Math实例话浪费堆空间，直接使用类本身。（类似全局）
* 静态的方法代表不需要实例对象的行为，直接用类来调用。
* 可以是使用构造函数私有化，防止非抽象类初始化。
* 静态方法不能调用该类非静态的实例变量和非静态方法（无法知道具体是哪个实例对象的实例变量和方法）
* 静态变量对所有实例对象都是一样的，被所有实例对象共享。
* 静态变量会在任何静态方法执行前初始化。
* 静态变量加上final后成为常数，常数最好全大写表示。
* final不止可以用在static上：final的变量表示初始化对象后不能修改；final的方法代表子类不能覆盖它的值；fianl的类表示不能被继承。
* autoboxing：自动包装。在ArrayList中装入privitive变量会自动包装成类。
* String.formate对数据格式化，%[argument number][flas][widht][.precision]type;例 ***%,6.1f*** ，除了 ***argument number***都是使用上42.000表示为 00,042.0,唯一的必填项是类型（type）
* Calendar日期处理类，Calendar.geIntentance()会根据地区方法子类。
### 10、异常处理
* 编译器所关心的是称为检查异常的异常。即文件是否在，服务器是否正常等。不关心逻辑异常。
* finally用来运行不管是否抛异常都要运行的代码。即使try和catch有return操作也会运行finally，会在执行完fianlly后在return
* 可以catch多个异常，只要在throws有声明。为每个需要单独处理的异常单独写代码块，若用父类来接收，会无法判断具体哪里异常。
* 有多个catch块，要小到大。
* 不想处理可以ducking掉，即甩锅，让上级去处理。
### 11、序列化和文件的输入/输出
* 对对象实例变量状态保存，可以将对象实例变量状态序列化（serialization）写入文件。
* 要让类能够被序列化，需要实现Serialization接口。
* 序列化是全部实现和全不实现的。
* 如果某个实例变量无需序列化，只要在将它标记为transient。
* 解序列化（deserialization），还原对象。解序列化是会在堆中创建相同状态的对象。而之前不可序列化的负累的构造方法又会初始化执行。transient的状态会被赋予默认值。在解序列化时对应的所有类都要能被找到。
* 静态变量无法被序列化。
* 使用ObjectOutputStream来序列化对象，用FileOutputStream来链接ObjectOutputStream的流来输出到文件。用WriteObject来是对象序列化。
* 写入文本文件，可让人查看，用FileWrite代替FileOutputStream
* File这个类代表磁盘上的文件，但不能读取文件内容。
* 缓冲区：由于内存和磁盘读写速度的缘故，所以有缓冲区能够保存数据，知道满时在写入磁盘，减少对磁盘的读取次数。
* FileReader来读取文件，知道FileReader的readLine为null为止。
* 为了防止解序列化时类已经被更改，导致无法正常还原，所以在序列化时会加上一个版本识别ID（SerializationUID）,使用serialver工具取得版本ID，把
  
        static final long serializationUID
    写在类中。
### 12、网络与线程
* socket网络连接
* InputStreamReader读取链接流，用BufferedReader来读取读取
* 用PrintWriter来写数据到流中
* Thread来建立新的线程，有runnable来确定执行的任务。
* 线程调度器来决定线程在执行与可执行之间的状态，无法控制调度器。
* 线程会引发竞争问题，即两个线程对同一个数据进行setter和getter会产生竞争问题。
* 使用synchronized是执行方法原子化，每个对象都有一把锁，而这些锁只有一把钥匙，在执行同步化方法时需要这把钥匙。
* 同步化也可以只同步几条指令。
```
    synchronized(this){
        第一行；
        第二行；
    }
```
* 同步化可能会造成线程等待，降低运行速度的问题；对方手都有自己钥匙，都不放开，会造成死锁问题。
### 13、集合和泛型
* 集合
  * ArrayList：最常用的集合
  * TreeSet：以有序状态保持并防止重复
  * HashMap：可以成对的 name/value 来保存和取出
  * LinkedList：针对经常插入删除所设计的高效率集合
  * HashSet：防止重复的集合，可快速寻找相符合的元素
  * LinkedHashMap：类似HashMap，但可记住元素插入的顺序，也可设定成元素上次存取的先后来排序。
* 可是使用TreeSet和Collections.sort()来进行排序
* 运用泛型可以创建类型安全更好的集合，让问题尽可能在编译期就被发现。
* 对泛型来说extends这个关键字适用于类和接口，可是Collections.sort要传入list的对象钥匙实现Comparable接口
* 要让set能把对象视为重复，有equal返回true，且两者的hashCode()相等
* treeSet排序：让排序类实现Comparable接口；让类实现Comparator<T>接口，创建TreeSet构造时传过去该类对象。
### 14、枚举
* enum
### 15、反射
* 解决在运行期间，对某一实例一无所知的情况下，如何调用其方法。
* 通过对象来获取类的所有信息称为反射。
* 如何获取类的类实例
    * 通过类class的静态变量class来获取
    ```java
        Class cls = String.class 
    ```
    * 对象提供的getClass()方法
    ```java
        String s = "Hello";
        Class cls = s.getClass();
    ```
    * 如果知道一个类的完整类名，可以通过静态方法Class.forName()获取。
    ```java
        Class cls = Class.froName("java.lang.String")
    ```
* 因为类实例在java虚拟机中是唯一的，所以上面三个取的都是同一个对象。
* instanceof是用来判断对象数据类型的
* 动态代理：
### 15、注解
* 从java虚拟机看，注解本身对逻辑没有影响，如果使用注解完全在于工具的决定。
* java通过@interface来定义注解（Annotation）
* 元注解：可以修饰其他注解
###  面试题
#### 1、为什么重写equal()也要重写hashCode()?
* 因为equal的默认实现是==，而引用变量的==要返回true，则需要指向同一个对象，即hashcode要相等，所以两个对象，equal肯定返回的false.所以当重写了equal使两个对象相等后，也要将hashcode重写，否则在equal时判断了相等，而其他地方判断为false：比如在map中判断key时。
#### 2、==和equals的区别
* ==是比较两个变量的值，如果是primitive值直接比较值，如果是引用变量比较是否是同一个对象，也就是引用变量报错的对象地址。
* equal只能对对象实现，默认实现也是==，只不过一般都会对equal进行重写，如String类就对equal进行了重写。
#### 3、为啥有时会出现4.0-3.6 = 0.40000001这种现象
* 因为在二进制中无法正确表时1/10，因为计算机中二进制表示为1/2^n,如0.5=1/2，0.75 = 1/2 + 1/4，而0.1无法精确表示
#### 4、final关键字作用
* final能够使数据无法被修改：final用在变量上，表示对象初始化变量后无法修改，使用在方法上表示子类无法覆盖该方法，使用在类上表示该类无法被继承，用在static的静态变量中国呢表示类似常量。
#### 5、介绍java的集合类
* List和Map可变化大小的列表
* ArrayList：最常用的集合
* TreeSet：以有序状态保持并防止重复
* HashMap：可以成对的 name/value 来保存和取出
* LinkedList：针对经常插入删除所设计的高效率集合
* HashSet：防止重复的集合，可快速寻找相符合的元素
* LinkedHashMap：类似HashMap，但可记住元素插入的顺序，也可设定成元素上次存取的先后来排序。
#### 6、ArrayList和LinkedList的区别
* ArrayList类似于数组，LinkedList类似于双向链表，所以相对于ArrAyList更方便在中间插入删除，但更占内存，因为每个节点要有前后两个节点引用。