# 一、概述

## 1、 字节码文件的跨平台性

### 1.1 Java语言：跨平台的语言（write once，run anywhere）

* 当Java源代码成功编译成字节码后，如果想在不同的平台上面运行，则无需再次编译
* 这个优势不再那么吸引人了。Pyton、PHP、Perl、Ruby、Lisp等有强大的解释器
* 跨平台似乎已经快成为一门语言必选的特性

### 1.2 Java虚拟机：跨语言的平台

* Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联。无论使用各种语言进行软件开发，只要能将语言文件编译为正确的class文件，那么这种语言就可以再Java虚拟机上执行。可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁

![image-20231206222425721](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312062224799.png)

* java虚拟机的规范，也就是说所有的JVM环境都是一样的，这样一来字节码文件可以在各种JVM上运行

* 想要一个Java程序正确的运行在JVM中，Java源码就必须要被编译为符合JVM规范的字节码

  * 前端编译期的主要任务就是负责件更符合Java语法规范的Java代码转换为符合JVM规范的字节码文件
  * javac是一种能够将Java源码编译为字节码的前端编译器
  * javac编译器在讲java源码编译为一个有效的字节码的过程中经历了4个步骤，分别是词法解析、语法解析、语义解析以及生成字节码

  ![image-20231206222814181](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312062228236.png)

* Oracle的JDK软件包括两部分内容

  * 一部分将Java源代码解析成Java虚拟机的指令集的编译器
  * 另一部分是用于实现Java虚拟机的运行时环境

## 2、Java的前端编译器

![image-20231206223158693](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312062231758.png)

### 2.1 前端编译器 vs 后端编译器

* Java源代码的编译结果是字节码，那么肯定需要有一种编译器能够将Java源码编译为字节码。承担这个重要责任的就是配置在path环境变量中的javac编译器。javac是一种能够将Java源码编译为字节码的前端编译器
* HotSpot VM并没有强制要求前端编译器只能使用javac来编译字节码，其实只要编译结果符合JVM规范都可以被JVM所识别即可。在Java的前端编译器领域，处理javac之外，还有一种被大家经常用到的前端编译器，那就是在内置在Eclipse中的ECJ（Eclipse Compiler for java）编译器。和Javac的全量式编译不同，ECJ是一种增量式编译器
  * 在Eclipse中，当开发人员编写完代码后，使用个“ctrl+s”快捷键时，ECJ编译器所采取的编译方案是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此ECJ的编译效率会比javac更加迅速和高效，当然编译质量和javac相比大致还是一样的
  * ECJ不仅是Eclipse的默认内置的前端编译器，在Tomcat中同样也是使用ECJ编译器来编译jsp文件。由于ECJ编译器是采用GPLv2的开源洗衣进行源代码公开，所以，大家可以登录eclipse官网下载ECJ编译器的源码进行二次开发
  * 默认情况下，IntelliJ Idea使用javac编译器（还可以自己设置为AspectJ编译器ajc）
* 前端编译器并不会直接设计编译优化等方面的技术，而是将这些具体的优化细节移交给HotSptot的JIT编译器负责

## 3、透过字节码指令看代码细节

* 成员变量（非静态的）赋值过程：①默认初始化②显式初始化/代码块中给出实话③构造器初始化③有了对象之后的方式对成员变量进行赋值
* 属性变量不呈现多态性

# 二、虚拟机的基石：Class文件

## 1、字节码文件里是什么

* 源代码经过编译器编译之后便会生辰给一个字节码文件，字节码是一种二进制的类文件，它的内容是JVM的指令，而不像C、C++经由编译器直接生成机器码

## 2、什么是字节码指令（byte code）

* Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码（opcode）以及跟随其后的零至多个代表此操作所需参数的操作数（operand）所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。比如：

![image-20231206235807172](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312062358232.png)

## 3、如何解读供虚拟机解释执行的字节码

* `javap -v xxx.class > test.txt`
* 使用idea插件jclasslib

# 三、Class文件结构

* Class类的本质：任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。Class文件是一组以8为字节为基础单位的二进制流
* Class文件格式：Class的结构不像XML等描述语言，由于它没有任何分割符号。所以在其中的数据项，无论是字节顺序还是数量，都是被阉割限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变
* Class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构只有两种数据类型：无符号数和表
  * 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值
  * 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯的以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明
* clas文件结构概述：class文件的结构并不是一成不变的，随着Java虚拟机的不断发展，总是不可避免地会对Class文件结构做出一些调整，但是其基本结构和框架是非常稳定的。Class文件的总体结构如下：
  * 魔数
  * Class文件版本
  * 常量池
  * 访问标志
  * 类索引，父类索引，接口索引集合
  * 字段表集合
  * 方发表集合
  * 属性表集合

![image-20231207002256061](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312070022203.png)

![image-20231207002341675](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312070023762.png)

## 1、魔数（Magic Number）

* 每个Class文件开头的4个字节的无符号整数称为魔数（Magic Number）

* 它的唯一作用是确定这个文件是否为一个能被虚拟机接收的有效合法的Class文件。即：魔数是Class文件的标识符

* 魔数值固定为0xCAFEBABE.不会改变

* 如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误

  ![image-20231207003328979](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312070033054.png)

* 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动

![image-20231207011823995](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312070118089.png)

## 2、Class文件版本号

* 紧接着魔数的4个字节存储的Class文件的版本号。同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号minor_version，而第7个和第8个字节就是编译的主版本号major_version

* 它们共同构成了class文件的格式版本号。譬如某个Class文件的主版本号M，副版本号m，那么这个Class文件的格式版本号就是M.m

* 版本号和Java编译器对应的关系如下表

  ![image-20231207011914623](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312070119703.png)

* Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1

* 不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的class文件，但是低版本的Java虚拟机不能执行由高版本编译生成的Class文件。否则Jvm会抛出java.lang.UnsupportedClassVersionError异常。（向下兼容）

* 在实际应用中，由于开发环境和生产环境不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译JDK版本和生产环境中的JDK版本是否一致

  * 虚拟机JDK版本为1.k（k>=2）时，对应的class文件格式版本号的范围为45.0-44+k.0（含两端）

![image-20231207012857118](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312070128235.png)

## 3、常量池：存放所有常量

* 常量池是Class文件中内容最为丰富的区域之一。常量池对于Class文件中的字段和方法解析也有着至关重要的作用
* 随着Java虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个Class文件的基石
* 在版本号之后，紧随着的是常量池的数量，以及若干个常量池表项
* 常量池中常量的数量是不固定，所以在常量池的入口需要放置一项u2类型的无符号数，代表常量池容量计数值（constant_pool_count）。与Java中语言新冠不一样的是，这个容量计数是从1而不是0开始的
* Class文件使用衣蛾前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池的内容。我们把这一系列连续常量池数据称为常量池集合
  * 常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容讲在类加载后进入方法区的运行时常量池中存放

### 3.1 constant_pool_count（常量池计数器）

* 由于常量池的数量的不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值
* 常量池容量计数值（u2类型）：从1开始，表示常量池中有多少项常量。即constant_pool_count=1表示常量池中有0个常量项

![image-20231207235954591](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312072359731.png)

* 其值为`0x0016`，掐指一算，也就是22
* 需要注意的是，这实际上只有21项常量。索引范围是1-21
* 通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示

### 3.2 constant_pool[]（常量池）

* constant_pool[]是一种表结构，以1~constant_pool_count-1为索引。表明了后面有多少个常量项
* 常量池主要存放两大类常量，字面量（Literal）和符号引用（Symbolic References）
* 它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte（标记字节、标签字节）

![image-20231208000330813](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312080003108.png)

#### 3.2.1 字面量和符号引用

* 在对这些常量解读前，我们需要搞清楚几个概念

* 常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。如下表

  ![image-20231208000941961](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312080009024.png)

* 全限定名

  * com/smc/java/Demo这个就是类的全限定名，仅仅是把包名的"."替换成"/"，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”标识全限定名结束

* 简单名称

  * 简单名称是指没有类型和参数修饰的方法或者字段名称，上面的例子中的类add()方法和num字段的简单名称分别是add和num

* 描述符

  * 描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用L加对象的全限定定名来表示。

  ![image-20231208001701445](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312080017518.png)

  * 用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法java.lang.String toString()的描述符为()Ljava/lang/String;，方法int abc(int[] x,int y)的描述符为([II) I.

* 补充说明

  * 虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用个，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。
  * 这里说下符号引用和直接引用的区别和关联
    * 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中
    * 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能直接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用挂载不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明的目标必定已经存在于内存之中。

![image-20231208005253596](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312080052732.png)

  ![image-20231208005032634](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312080050717.png)![image-20231208004229543](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312080042676.png)![image-20231208005359219](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312080053303.png)

#### 3.2.2 总结1

* 这14中表（或者说常量项结构）的共同点是：表开始的第一位是一个u1类型的标志为（tag），代表当前这个常量项使用的是那种表结构，即哪种常量类型
* 在常量池列表中，CONSTANT_Utf8_info常量项是一种使用改进的UTF-8编码格式来存储注入文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符第二个常量字符串信息
* 这14中常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定。为什么呢？因为从常量池存饭的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小实在编写程序时才确定，比如你定义一个类，类名可以取长补短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度

#### 3.2.3 总结2

* 常量池：可以理解为Class文件中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用Class文件空间最大的数据项目之一
* 常量池中为什么要包含这些内容
  * Java代码在进行Javac编译的时候，并不想C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

## 4、访问标识（access_flag、访问标志、访问标记）

* 在常量池后，今个这访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public累心个；是否定义为abstract类型；如果是类的话是否被声明为final等。

  ![image-20231209141708644](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091417006.png)

* 类的访问权限通常为ACC_开头的常量

* 每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL

* 使用ACC_SUPER可以让类更准确地定位到父类的方法super.method()，现代编译器都会设置并且使用这个标记

### 4.1补充说明

* 带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。
  * 如果一个class文件被设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志，同时它不能再设置ACC_FINAL、ACC_SUPER或ACC_ENUM标志
  * 如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表中出ACC_ANNOTATION以外的其他所有标志，当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外，这两个标志不得同时设置
* ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译期都应当设置这个标志。对于Java SE 8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个class文件均设置了ACC_SUPER标志
  * ACC_SUPER标志是为了向后兼容由旧Java编译器所编译的代码而设计的。目前的ACC_SUPER标志在由JDK 1.0.2之前的编译器所生成的access_flags中是没有确定含义的，如果设置了改标志，那么Oracle的Java虚拟机实现会将其忽略
* Acc_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是由源代码生成的
* 注解类型必须shezhiACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么必须设置ACC_INTERFACE标志
* ACC_ENUM标志表明该类或其父类为枚举类型
* 表中没有使用的access_flags标志是为未来扩充而预留的，这些预留的标志在编译期中应该设置为0，Java虚拟机实现也应该忽略他们

![image-20231209143232867](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091432038.png)

## 5、类索引、父类索引、接口索引集合

* 在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：

​	![image-20231209143603950](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091436026.png)

* 这三项数据来确定这个类的继承关系
  * 类索引用于确定这个类的全限定名
  * 付类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，处理java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0
  * 解耦索引集合用于来描述这类实现了哪些接口，浙西被实现的接口将按implements语句（如果这个类本身是一个接口，则应当extends语句）后的接口顺序从左到右排列在接口索引表中

### 5.1 this.class(类索引)

* 2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java/lang/Object类。同时，由于Java不支持多继承，所以其父类只有一个
* superclass直线给的父类不能是final

![image-20231209143506801](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091435951.png)

### 5.2 interfaces

* 指向常量池索引的集合，它提供了衣蛾符号引用到所有已实现的接口
* 由于一个类可以实现多个接口，因此需要以数组形式报错多个接口的索引，表示接口的每个索引也是一个指向常量池的CONSTANT_Class（当然这里必须是接口，不能是类）

![image-20231209144338576](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091443712.png)

#### 5.2.1 interfaces_count(接口计数器)

* interfaces_count项的值表示当前类或接口的直接超接口数量

#### 5.2.2 interfaces[]（接口索引集合）

* interfaces[]中每个成员的值必须是对常量池表中谋陷给的有效索引值，它的长度为interfaces_count.每个成员interfaces[i]必须为CONSTANT_Class_info接口，其中0<=i<interfaces_count。在interfaces[]中，哥成员所表示的接口顺序和对应的源代码中给定的接口顺序一样，即interfaces[0]对应的源代码中最左边的接口

## 6、字段表集合(fields)

* 用于描述接口或类中声明的变量。字段（filed）包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量。（local variables）
* 字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述
* 它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符（public、private或protected）、是类变量还是实例变量（static修饰符）、是否是常量（final修饰符）等

### 6.1 注意事项

* 字段表集合中不会列出父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段
* 在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的

### 6.2 fields_count(字段计数器)

* fields_count的值表示当前class文件fields表的成员个数。使用搞两个字节来表示
* fields表中每个成员都是一个field_info接口，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或付接口继承的那些字段

![image-20231209145902337](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091459504.png)

### 6.3 fields[]字段表

* fields表中的每个成员都必须是一个fields_info接口的数据项，用于表示当前类或接口中某个字段的完整描述

* 一个字段的信息包括如下这些信息。这些信息中，各个修饰符都是布尔值，要么有，要么没有

  * 作用域（public、private、protected修饰符）
  * 是实例变量还是类变量（static修饰符）
  * 可变性（final）
  * 并发可见性（volatile修饰符，是否强制从主内存读写）
  * 可否哦序列化（transient修饰符）
  * 字段数据类型（基本数据类型、对象、数组）
  * 字段名称

* 字段表结构

  ![image-20231209150310552](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091503803.png)

 #### 6.3.1 字段表访问标识

* 我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static修饰符、final修饰符、volatile修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些

  ![image-20231209150543744](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091505841.png)

#### 6.3.2 字段名索引

* 根据字段名索引的值，查询常量池中的指定索引项即可

#### 6.3.3 描述符索引

* 描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte,char,double,float,int,long,short,boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示

  ![image-20231209150920637](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091509813.png)

#### 6.3.4 属性表集合

* 一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count中，属性具体内容存放在attributes数组中

  ![image-20231209151353720](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091513907.png)

  

![image-20231209151117315](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091511419.png)

## 7、方法表集合（methods）

* 指向常量池索引集合，它完整的描述了每个方法的签名
  * 在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private或protected），方法的返回值类型以及方法的参数信息等
  * 如果这个方法不是抽象的或者不是native的，那么字节码汇总会体现出来
  * 一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或付接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器唱的方法信息（比如：类（接口）初始化方法\<clinit\>()和实力初始化方法\<init\>()）

### 7.1 使用注意事项

![image-20231209152136747](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091521881.png)

### 7.2 方法计数器

* methods_count的值表示当前class文件methods表的成员个数，使用两个字节来表示
* methods表中每个成员都是一个method_info结构

### 7.3 methods[]（方法表）

* method是表中的每个成员都必须是一个method_info 结构，用于比哦啊是当前类或接口中某个方法的完整描述。入股某个method_info结构的access_flags项既没有设置ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令

* method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实力初始化方法和类或接口的初始化方法

* 方法的结构实际个字段表是一样的

  ![image-20231209152637614](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091526716.png)

#### 7.3.1 方法表访问标志

* 跟字段表一样，方发表也有访问标志，而且他们的标志有部分相同，不分子不同，范发表的具体访问标志如下

![image-20231209153448058](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091534185.png)

## 8、属性表集合（attributes）

* 方法表集合之后的属性表，指的是class文件所携带的辅助信息，比如该class文件的源文件的名称。以及任何带有RetentionPolicy.CLASS或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无需深入了解
* 此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息
* 属性表集合的限制没有那么严格，不在要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以项属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性

### 8.1 attribates_count(属性计数器)

* attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构

### 8.2 attributes[]（属性表）

* 属性表的每一个值必须是attribute_info结构。属性表的结构比较灵活，各种不同的属性只要满足一下结构即可

#### 8.2.1 属性的通用格式

![image-20231209154332244](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091543469.png)

#### 8.2.3 属性类型

* 属性表实际上可以有很多类型，上面看到的Code属性只是其中一种，Java8里面定义了23种属性

![image-20231209161047341](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091610653.png)

### 8.3 sourceFile

![image-20231209161537056](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091615193.png)

## 9、javap指令解析Class文件

### 9.1、javac -g 操作

* 你直接javac xx.java，就不会生成对应的局部变量表等信息，如果你使用javac -g xx.java就可以生成所有相关信息。如果你使用的eclipse或IDEA，则默认情况下，eclipse、IDEA在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息 

### 9.2、javap的用法

* javap的用法格式`javap <option><classes>`
* 其中classes就是你要反编译的class文件

![image-20231209191326234](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312091913698.png)

* javap -l 会输出行号和本地变量表信息
* javap -c 会对当前class字节码进行反编译生成汇编代码
* javap -vclassxx除了包含-c内容外，还会输出行号、局部变量表信息、常量池等信息

# 四、字节码指令集与解析举例

## 1、概述

* Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令
* Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码、Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数、Operands）而构成。由于Java迅疾采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码
* 由于限制了Java虚拟机操作码的长度为一个字节（即0~255），这意味着指令集的操作码总数不可能超过256条
* 熟悉虚拟机的指令对于冬天字节码生成、反编译Class文件、Class文件修补都有着非常重要的价值。因此，月度字节码作为了解Java虚拟机的基础技能，需要熟练掌握常见指令

### 1.1 执行模型

* 如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解

![image-20231210003657981](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312100036165.png)

### 1.2、字节码与数据类型

* 在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令都用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是fload类型的数据
* 对于大部分与数据类型相关的字节码指令，他们的操作码助记符中都有特殊的字符来表明专门为那种数据类型服务
  * i代表int类型的数据操作
  * l代表long
  * s代表short
  * b代表byte
  * c代表char
  * f代表float
  * d代表double
* 也有一些指令的助记符中没有明确地知名操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象
* 还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的
* 大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期货运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相对应的int类型作为运算类型

### 1.3 指令分类

* JVM中的字节码指令集按用途大致分成9类
  * 加载与存储指令
  * 算数指令
  * 类型转换指令
  * 对象的创建与访问指令
  * 方法调用与返回指令
  * 操作数栈管理指令
  * 比较控制指令
  * 异常处理指令
  * 同步控制指令

* 在做值相关的操作时：
  * 一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能会死值，可能是对象的引用）被 压入操作数栈
  * 一个指令，也可以从操作数栈中取出一个到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等操作

## 2、加载与存储指令

* 作用

  * 加载与存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递

* 常用指令

  ![image-20231210170719346](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101707560.png)

* 上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_\<n\>）。这些指令助记符实际上代表了一组指令（例如iload\_\<n\>代表了iload_0,iload_1,iload_2和iload_3这几个指令）。这机组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这若干组特殊指令来说，他们表面上没有操作数，不需要进行曲操作数的动作，但操作数都隐含在指令中。
* 除此之外，他们的语义与原生的通用指令完全一致（例如iload_0的语义与操作数为0时的iload的指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，\<n\>代表非负的整数，\<i\>代表是int类型数据，\<l\>代表龙累心个，\<f\>代表float类型，\<d\>代表double类型
* 操作byte、char、short和booloean类型数据时，经常用int类型的指令来表示

### 2.1 再谈操作数栈与局部变量表

![image-20231210171649472](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101716821.png)

#### 2.1.1 操作数栈

* 我们知道，Java字节码是Jva虚拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。

* 在解释执行过程中，每当Java方法分配栈帧时，Java虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果

* 具体来说便是：执行每条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中，在执行指令时，Java虚拟机会将该指令所需的操作数据弹出，并且将指令的结果重新压入占中。

  ![image-20231210172005285](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101720503.png)

* 由于加法指令iadd为例。假设在执行该指令前，栈顶的两个元素分别为int值1和int值2，那么iadd指令将弹出这两个int，并将求得的和int值3压入栈中

  ![image-20231210172138556](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101721701.png)

* 由于iadd指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd指令并不关心它是否存在，更加不会对其进行修改

#### 2.1.2 局部变量表（Local Variables）

* Java方法栈帧的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。

* 实际上，Java虚拟机将局部变量区当做一个数组，一次存放this指针（仅非静态方法），所传入的参数，以及字节码中的局部变量

* 和操作数栈一样，long类型以及double类型的值将占据两个单元，其余类型仅占据一个单元

  ![image-20231210172905543](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101729671.png)

  ![image-20231210173305783](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101733890.png)

* 在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根结点，只要被局部变量表中直接或间接引用的对象都不会被回收
* 在方法执行时，虚拟机使用局部变量表 完成方法的传递

### 2.2 局部变量压栈指令

* 局部变量压栈指令将给定的局部变量表中的数据压入操作数栈

  ![image-20231210175707177](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101757385.png)

  ![image-20231210175817525](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101758815.png)

### 2.3 常量入栈指令

* 常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为const系列、push系列和ldc指令

![image-20231210180440090](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101804478.png)

![image-20231210180912257](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101809495.png)

### 2.4 出栈装入局部变量表指令

* 出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值
* 这类指令主要以store的形式存在，比如xstore（x为i、l、f、d、a）、xstore_n（x为i、l、f、d、a，n为0至3）
  * 其中，指令istore_n将从操作数栈中弹出一个整数，并把它赋值给局部变量索引n位置
  * 指令xstore由于没有隐含参数信息，故需要提供一个byte类型的参数类指定目标局部变量表的位置

![image-20231210182300890](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101823381.png)

* 说明
  * 一般来说，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是为了尽可能压缩指令大小，使用专门的istore_1指令表示将弹出的元素放置在局部变量表的第一个位置。类似的还有istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表的 第0,2,3个位置
  * 由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于3，那么可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置

## 3、算法指令

* 作用：算数指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈

* 分类：大体上算数指令可以分为两种：对整型数据进行运算的指令与对浮点类型数据进行运算的指令

* byte、short、char和bolean类型说明

  ![image-20231210192041107](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101920314.png)

* 运算时的溢出
  * 数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有触发指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常ArithmeticException
* 运算模式
  * 向最接近数舍入模式：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可悲表示的最接近的精确值，如果有两种可标识的形式与该值一样接近，将优先选择最低有效位为零的
  * 向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果
* NaN值使用
  * 当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值来表示。而且所有使用NaN值作为操作数的算数操作，结果都会返回NaN。

### 3.1 所有的算数指令

![image-20231210193406913](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101934237.png)

![image-20231210194210646](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101942015.png)

![image-20231210194244313](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101942600.png)

### 3.2 比较指令的说明

![image-20231210195225506](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101952914.png)

![image-20231210195920520](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101959644.png)

![image-20231210195940891](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312101959089.png)

## 4、类型转换指令

### 4.1 类型转换指令说明

* 类型转换指令可以将两种不同的数值类型进行相互转换
* 这些转换操作一般用于实现代码中的显示类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题

### 4.2 宽化类型转换

#### 4.2.1 转换规则

* Java虚拟机直接支持一下数值的宽化类型转换（widening numeric conversion，小范围类型相大范围类型的安全转换）。也就是说，并不需要指令执行，包括
  * 从int类型到long、float或者double类型，对应的指令为i2l,i2f,i2d
  * 从long类型到float、double类型，对应的指令为l2f,l2d
  * 从float类型到double类型。对应的指令为f2d

![image-20231217135553780](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312171355168.png)

#### 4.2.2 损失精度问题

* 宽化类型转换是不会因为超过目标类类型最大值而损失信息的，例如，从int转换到long，或者从int转换到double，都不会丢失任何信息，转换前后的值是精确相等的
* 从gint、long类型转换到float，或者long类型数值转换到double时，将可能发生精度丢失--可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近摄入模式所得到的正确整数值
* 尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java虚拟机爬出运行时异常。

![image-20231217140125219](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312171401358.png)

#### 4.2.3 补充说明

* 从byte、char和short类型到int类型的宽化类型转换实际上是不存在的。对于byte类型转为int，虚拟机并没有做实质性的转化处理，只是简单的通过操作数栈交换了两个数据。而将byte转为long时，使用的是i2l，可以看到在内部byte在这里已经等同于int类型处理了，类似的还有short类型，这种处理方式有两个特点：
  * 一方面可以减少实际的数据类型，如果为short和byte都准备一套指令，那么指令的数量就会大增，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将short和byte当做int处理也在清理之中
  * 另一个方面，由于局部变量表中的槽位固定为32位，无论是byte或者是short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型 

### 4.3 窄化类型转换（Narrowing Numeric Conversion）

#### 4.3.1 转换规则

* Java虚拟机也直接支持一下窄化类型转换
  * 从int类型至byte、short或者char类型。对应的指令有：i2b,i2s,i2c
  * 从long类型到int类型。l2i
  * 从float累心管道int或者long类型。f2i,f2l
  * 从double类型到int、long或者float类型。d2i,d2l,d2f

#### 4.3.2 精度损失问题

* 窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度
* 尽管数据类型窄化转换可能会发生上线溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常

#### 4.3.3 补充说明

* 当讲一个浮点值窄化转换为整数类型T（T限于int或者long类型之一）的时候，将遵循以下转换规则：
  * 如果浮点值是NaN，那转换结果就是int或long类型的0
  * 如果浮点值不是无穷大的话，浮点值使用IEE 754 的向零舍入模式取整，获得整数值v，如果v在目标类型T（int或long）的表示范围之内，那转换的结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数
* 当将一个double类型窄化转换为float类型时，将遵循以下转换规则：通过向最接近书舍入模式舍入一个可以使用float类型表示的数字。最后的结果根据下面这3条规则判断：
  * 如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零
  * 如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大
  * 对于double类型的NaN值按规定转换为float类型的NaN值

## 5、对象的创建与访问指令

* Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列专门用于对象操作，可进一步细分为创建指令，字段访问指令，数组操作指令，类型检查指令

### 5.1 创建指令

* 虽然类型实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令

* 创建类实例的指令：new

  * 它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈

  ![image-20231217144311461](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312171443732.png)

* 创建数组的指令：newarray、anewarry、multianewarray

  * newarray：创建基本类型数组
  * anewarry：创建引用类型数组
  * multianewarray：创建多维数组

* 上述创建指令可以用于创建对象或者数组，由于对象和数组在Java中的广泛使用，这些指令的使用频率也非常高

### 5.2 字段访问指令

* 对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素
  * 访问类字段（static字段、或者成为类变量）的指令：getstatic、putstatic
  * 访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield

![image-20231217151558779](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312171515879.png)

![image-20231217152035086](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312171520213.png)

### 5.3 数组操作指令

* 数组操作指令主要哟：xastore和xaload指令，具体为：

  * 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload
  * 将一个操作数栈的值存储到数组元素的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore

  ![image-20231217164714294](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312171647425.png)

* 取数组长度的指令：arraylength
  * 该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈

* 说明
  * 指令xaload表示将数组的元素压入栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引i，栈顶顺位第2个元素为数组引用a，该指令会弹出栈顶这两个元素，并将a[i]重新压入栈
  * xasotre则专门针对数组操作，以iastore为例，它用于给一个int数组的给定索引赋值。在iastore执行前，操作数栈顶需要以此准备3个元素：值、索引、数组引用，iastore会弹出这3个值，并将值赋给数组中指定索引的位置

### 5.4 类型检查指令

* 检查类实例或数组类型的指令：instanceof、checkcast
  * 指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常
  * 指令instanceof用来判断给定对象是否是某一个类的实例，它将会判断结果压入操作数栈

![image-20231217170328711](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312171703003.png)

## 6、方法调用与返回指令

### 6.1 方法调用指令

* invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分派方式

* invodeinterface指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出合适的方法进行调用。

* invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会再调用时进行动态派发

  ![image-20231217171304876](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312171713961.png)

* invokestatic指令用于调用命名类中的类方法（static方法）。这是静态绑定的

* invokedynamic：调用动态绑定的方法，这个是JDK1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在hava虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的

### 6.2 方法返回指令

* 方法调用结束前，需要进行返回。方法返回指令时根据返回值的类型区分的

  * 包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn
  * 另外还有一条return指令供生命为void的方法、实例初始化方法以及类和接口的类初始化使用的方法

  ![image-20231217172149482](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312171721603.png)

![image-20231217172321642](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312171723752.png)

## 7、操作数栈管理指令

* 如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令

* 这类指令包括如下内容：

  * 将一个或两个元素从栈顶弹出，并且直接废弃：pop，pop2；
  * 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup，dup2，dup_x1，dup2_x1，dup_x2，dup2_x2
  * 栈顶最顶端的两个Slot数值位置交换Lsqap。Java虚拟机没有提供交换两个64为数据类型（long，double）数值的指令
  * 指令nop，是一个非常特殊的指令，它的字节码为0x00。和汇编语言中的nop一样，它表示什么都不做。这条指令一般可用于调试、占位等

* 这些指令属于通用型，对栈的压入或者弹出无需指明数据类型

* 说明：

  * 不带_x的指令是复制栈顶数据并压入栈顶。包括两个指令dup和dup2.dup的系数代表要复制的slot个数
  * 带\_x的指令时赋值栈顶数据并插入栈顶以下的某个位置。共有4个指令，dup_x1，dup_x2，dup2_x2。对于带\_x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置

  * pop：将栈顶的1个Slot数值出栈
  * Pop2：将栈顶的2个Slot数值出栈。例如1个double类型数值，或者2个int类型数值

## 8、控制转移指令

### 8.1 条件跳转指令

* 条件跳转指令通产刚和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转

* 条件跳转 的指令有

  ![image-20231218003210730](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312180032060.png)

* 他们统一的安逸为：弹出栈顶元素，测试它是否满足某一条件，入股哦满足条件，则跳转到给定为止
* 注意：
  * 与前面的运算规则一直
    * 对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成
    * 对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整数值到操作数栈，随后在执行int类型的条件分支操作来完成整个分支跳转
  * 由于各类型的比较最终都会转为int类型的比较，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的

### 8.2 比较条件跳转指令

* 比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一

* 这类指令有

  ![image-20231218004701521](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312180047644.png)

* 这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令完成后，栈顶的这两个元素被清空，且没有任何数据入栈。如果预设条件成立，则执行跳转，否则，继续执行下一条语句

## 8.3 多条件分支跳转指令

* 多条件分支跳转指令是为了switch-case语句设计的，主要偶tableswitch和lookupswitch

  ![image-20231218225745996](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312182257303.png)

* 从助记符删观看，两者都是switch语句的实现，他们的区别：
  * tableswitch要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量为止，因此效率比较高
  * 指令lookupswitch内部存放着各个离散的case-offset对，每次执行都要搜索全部的case-offset对，找到匹配case值，并根据对应的offset计算跳转地址，因此效率较低

## 8.4 无条件跳转指令

* 目前主要的无条件跳转指令为goto。指令goto接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处
* 如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令goto_w，它和goto有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围

![image-20231218231003360](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312182310725.png)

## 8.5 异常处理指令

### 8.5.1 抛出异常指令

* athrow指令
  * 在Java程序中显示抛出异常的操作（throw）语句都是有athrow指令来实现。
  * 除了使用throw语句显示抛出之外，JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算是，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticExcetion异常
* 注意
  * 正常情况下，操作数栈的压入弹出都是一条条指令完成。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上

### 8.5.2 异常处理与异常表

* 处理异常：在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成的
* 异常表：如果一个方法定义了一个try-catch或者try-finally的异常处理，就会创建一个异常表。它包含了每个异常处理或finally块的信息。异常表保存了每个异常处理信息。比如
  * 起始位置
  * 结束位置
  * 程序计数器记录的代码处理的偏移地址
  * 被捕获的异常类在常量池中的索引
* 当一个遗产刚被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后的飞守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程
* 不管什么时候抛出异常，如果异常处理最终匹配了所有遗产格雷欣个，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行了finally块，在return前，它直接跳到finally块来完成目标

## 8.6 同步控制指令

### 8.6.1 方法级同步

* 是隐式的，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法
* 当调用方法时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否设置
  * 如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁
  * 在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁
  * 如果一个同步方法执行期间抛出异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。

![image-20231219002411209](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312190024424.png)

### 8.6.2 方法内指定指令序列的同步

* 同步一段指令集序列：通常是由java中的synchronized语句块来表示的。jvm的指令集有monitorenter和monitorexit两条指令来支持synchronized关键字的语义
* 当一个线程进入同步代码块是，它使用monitorenter指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，知道对象的监视器计数器为0，才会被允许进入。

![image-20231219002714991](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312190027440.png)

* 当线程退出同步块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。
* 指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象，之后monitorenter和monitorexit的锁定和释放都是针对这个对象的监视器进行的

# 五、类的加载过程（类的生命周期）详解

## 1、概述

* 在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载

* 按照Java虚拟机规范，从gclass文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段

  ![image-20231219004448606](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312190044775.png)

  * 其中验证、准备、解析3个部分统称为链接

* 从类的使用过程看

  ![image-20231219004613141](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312190046477.png)

## 2、过程一：Loading（加载）阶段

### 2.1 加载完成的操作

#### 2.1.1 加载的理解

* 所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型--类模板对象。所谓类模板对象，其实就是Java类在JVM内存中的一个快展，JVM件工资界面文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期间便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用
* 反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射

#### 2.1.2 加载完成的操作

* 加载阶段，简言之，查找并加载类的二进制数据，生成Class的实力
* 在加载类时，Java虚拟机必须完成一下3件事情
  * 通过类的全名，获取类的二进制数据流
  * 解析类的二进制数据流为方法区内的数据结构（Java类模型）
  * 创建java.lang.Class类的实力，表示该类型。作为方法区这个类的各种数据的访问入口

### 2.2 二进制流的获取方式

* 对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合JVM规范即可）
  * 虚拟机可能通过文件系统读入一个class后缀的文件（最常见）
  * 读入jar、zip等归档数据包，提取类文件
  * 实现存放在数据库中的类的二进制数据
  * 使用类似于HTTP之类的协议通过网络进行加载
  * 在运行时生成一段Class的二进制信息等
* 在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例
* 如果输入数据不是ClassFile的结构，则会抛出ClassFormatError

### 2.3 类模型与Class实例的位置

* 类模型的位置：加载的类在JVM中创建相应的类结构，类结构会存储在方法区（JDK1.8之前：永久代；JDK1.8之后：元空间）
* Class实例的位置：类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应一个Class类型的对象

![image-20231219221719852](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312192217087.png)

* 外部可以通过访问代表Order类的Class对象来获取Order的类数据结构
* 再说明：Class类的构造方法是私有的，只有JVM能够创建
* java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过Class类提供的接口，可以获得目标类所关联的.class文件中具体的数据结构：方法、字段等信息

### 2.4 数组类的加载

* 创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称A）的过程：
  * 如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型
  * JVM使用制定的元素类型和数组维度来创建新的数组类
* 如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性江北缺省定义为public

## 3、过程二：Linking（链接）阶段

### 3.1 环节1：链接阶段之Verification（验证）

* 当类加载到系统后，就开始链接操作，验证是链接操作的第一步

* 它的目的是保证加载的字节码是合法、合理并符合规范的

* 验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示：

  ![image-20231219224213751](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312192242174.png)

* 整体说明：验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等
  * 其中格式验证会和加载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。
  * 格式验证之外的验证操作将会在方法区中进行
* 链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查

#### 具体说明

* 格式验证：是否以魔数0xCAFEBABE开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中的每一个项是否都拥有正确的长度等
* 语义检查：Java虚拟机会进行字节码的语义检查，但凡在语义上部分规范的，虚拟机也不会给与验证通过。比如：
  * 是否所有的类都有父类的存在（在Java里，除了Object外，其他类都应该有父类）
  * 是否一些被定义为final的方法或者类被重写或继承了
  * 非抽象类是否实现了所有抽象方法或者接口方法
  * 是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让迅疾无从下手调度；abstract情况下的方法，就不能是final的了）
* 字节码验证：Java虚拟机还会进行字节码验证，字节码验证也是验证过程中最为复杂的一个过程。它试图通过对字节码流的分析，判断字节码是否可以被正确的执行。比如：
  * 在字节码的执行过程中，是否会跳转到一条不存在的指令
  * 函数的调用是否传递了正确类型的参数
  * 变量的赋值是不是给了正确的数据类型等
  * 栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变脸该表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确的判断一个段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确的装载这个类。但是，吐过通过了这个阶段的检查，也不能说明这个类是完全没问题的。
* 校验器还将进行符号引用的验证：Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法再系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError。

### 3.2 环节2：链接阶段之Preparation（准备）

* 为类的静态变量分配内存，并将其初始化为默认值

* 当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值

  ![image-20231219230512323](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312192305549.png)

* 注意，boolean内部实现是int，0是false，1是true
* 注意：
  * 这里不包含进本诗句类型的字段用static final修饰的情况，因为final在编译的时候就会分配了，准备阶段会显示赋值
  * 注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中
  * 在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行

### 3.3 环节3：链接阶段之Resolution（解析）

* 将类、接口、字段和方法的符号引用转为直接引用

#### 3.3.1 具体描述：

* 符号引用就是一些字面量的引用，和虚拟机的内部数据结构和内存布局无关。比较容易理解的就是在Class类文件中，通常常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用时不够的 ，比如当如下println()方法被调用时，系统需要明确知道该方法的位置

![image-20231219232731530](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312192327769.png)

* 以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用

#### 3.3.2 小结

* 所谓解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么可以肯定系统存在该类、方法或者字段。但只存在符号引用，不能确定系统重一定存在该结构。
* 不过Java虚拟机规范并没有明确要求解析阶段一定公钥按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行

## 4、过程三：Initialization（初始化阶段）

* 为类的静态变量赋予正确的初始值

* 具体描述：累的初始化时类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码（即：到了初始化阶段，才真正开始执行类中定义的Java程序代码）。初始化阶段的重要工作是执行类的初始化方法：\<clinit\>()方法

  * 该方法仅能有Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成
  * 它是由静态类成员的复制语句以及static语句块合并产生的

* 说明

  * 在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的\<clinit\>总是在子类\<clinit\>之前被调用。也就是说，父类的static块优先级高于子类

  * 口诀：先父后子，静态先行

  * Java编译器并不会为所有的类都产生\<clinit\>()初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含\<clinit\>()方法

    * 一个类中并没有声明任何的类变量，也没有静态代码块时
    * 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时
    * 一个类中包含static final 修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式

    ![image-20231220000025723](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312200000243.png)

### 4.1 static与final的搭配问题

![image-20231220001155339](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312200011643.png)

### 4.2 \<clinit\>()的线程安全性

* 对于\<clinit\>()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性
* 虚拟机会保证一个类的\<clinit\>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\<clinit\>()方法，其他线程都需要阻塞等待，知道活动线程执行\<clinit\>()方法完毕
* 正是因为函数\<clinit\>()带锁线程安全的，因此，如果在一个类的\<clinit\>()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息
* 如果之前的线程成功加载了类，则等待在队列中的线程就没有机会再执行\<clinit\>()方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息

### 4.3 类的初始化情况：主动使用vs被动使用

* Java程序对类的使用分为两种：主动使用和被动使用

#### 4.3.1 主动使用

* Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成）

  * 1、当创建一个类的实例是，比如使用new 关键字，或者通过反射、克隆、反序列化

  * 2、当调用类的静态方法时，即当使用了字节码invokestatic指令

  * 3、当使用类、接口的静态字段时，即当使用了字节码invokestatic指令

  * 4、当使用类、接口的静态字段时（final修饰特殊考虑），比如getstatic或者putstatic指令。（对应访问变量、赋值变量操作）

  * 5、当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName("com.smc.java.Test")

  * 6、当初始化子类时，如果发现其父类还没有进行初始化，则需要先出发其父类的初始化

    ![image-20231220005039158](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312200050234.png)

  * 7、如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化

  * 8、当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机辉县初始化这个主类

  * 9、当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（设计解析REF_getstatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）

#### 4.3.2 被动使用

* 对于类的被动使用，即不会进行类的初始化操作\<clinit\>()

1. 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化
   * 当通过子类引用父类的静态变量，不会导致子类初始化
2. 通过数组定义类的引用，不会出发此类的初始化
3. 引用常量不会出发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了
4. 调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化

* 说明：没有初始化的类，不代表没有被加载

## 5、过程四：类的Using（使用）

* 开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例

## 6、过程五、类的Unloading（卸载）

### 6.1 类、类的加载器、类的实例之间的引用关系

* 在类的加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系
* 一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象

### 6.2 类的生命周期

* 当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期
* 一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期

### 6.3 具体实例

![image-20231220235715729](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312202357546.png)

### 6.4 类的卸载

* 启动类加载器加载的类在整个运行期间是不可能被卸载的（jvm和jls规范）
* 被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小
* 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被类加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）

* 综合以上三点，一个已经加载的类被卸载的几率很小至少被卸载的时间是不确定的。同事我们可以看的出来，开发者在开发代码的时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能

 # 六、再谈类的加载器

## 1、概述

* 类加载器是JVM执行类加载机制的前提。
* ClassLoader的作用：
  * ClassLoader是Java的核心组件，所有的Class都是有ClassLoader加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行则由Execution Engine决定

![image-20231221001443886](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312210014184.png)

* 类加载器最早出现在Java1.0版本中，那个时候只是单纯的为了满足Java Applet应用而被研发出来。但如今类加载器却在OSGI、字节码加解密领域大放异彩。这主要归功于Java虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在JVM内部，这样做的好处就是能够更加灵活和动态地执行类的加载操作

### 1.1 类加载的分类

#### 显示加载 vs隐式加载

* class文件的显示加载与隐式加载的方式是指JVM加载class文件到内存的方式
  * 显示加载指定的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader()加载class对象
  * 隐式加载则不直接在代码中调用ClassLoader方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另一个类的兑现个，此时额外引用的类将通过JVM自动加载到内存中

### 1.2 类加载器的必要性

* 一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：
  * 避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题
  * 需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类的加载器打交道
  * 开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑

### 1.3 命名空间

#### 1.3.1 何为类的唯一性？

* 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。每一个类的加载器，都拥有一个独立的类名称空间；比较两个类是否相等，只有在这个类是由同一个类加载器加载的前提下才有意义。否则，即时这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就丙丁不相等的

#### 1.3.2 命名空间

* 每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成
* 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
* 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的类

![image-20231221004056895](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312210040204.png)

### 1.4 类加载机制的基本特征

* 通常类加载机制有三个基本特征
  * 双亲委派模型。但不是所有类加载器都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能 要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的视线，JDK也需要提供些默认的参考实现。例如，Java中JNDI，JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器
  * 可见性，子类加载器可以访问父类加载器加载的类，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑
  * 单一性，由于父加载器的类型对于子加载器是可见的，所以付加载器中加载过的类，就不会再子加载器中重复加载。但是主要，类加载器邻居间，同行已类型仍然是可以被加载多次的，因为互相不可见

## 2、类的加载器分类

* JVM支持两种类型的累加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）

* 从概念上讲，自定义类加载器一般指的会死程序中由开发人员自定义的一类加载器，但是Java虚拟机规范并没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况

  ![image-20231221005347310](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312210053474.png)

* 除了顶层的启动类加载器外，其余的类加载器都应当由自己的“父类”加载器

* 不同；类的加载器看似是集成（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用

  ![image-20231221005627642](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312210056871.png)

  

### 2.1 引导类加载器

![image-20231221005930806](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312210059020.png)

### 2.2 扩展类加载器

![image-20231221010542482](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312210105853.png)

### 2.3 系统类加载器

![image-20231221010802979](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312210108531.png)

### 2.4 用户自定义类加载器

![image-20231221010955033](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312210109201.png)

## 3、测试不同的类加载器

* 每个Class对象都会包含一个定义它的ClassLoader的一个引用

* 获取ClassLoader的途径

  ![image-20231221011135561](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312210111745.png)

* 说明：
  * 站在程序的角度看，引导类加载器与另外两种类加载器（系统了加载器和扩展类加载器）并不是同一层次意义上的类加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载器压根就不是一个Java类，因此在Java程序中只能打印NULL
  * 数组类的Class对象，不是有类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型是基本数据类型，数据是没有类加载器的

![image-20231221011741332](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312210117628.png)

## 4、 ClassLoader源码解析

### 4.1 ClassLoader与现有类加载器的关系

![image-20231221232557088](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312212325524.png)

 ### 4.2 ClassLoader的主要方法

* ` public final ClassLoader getParent()`：返回该类加载器的超类加载器

* ` public Class<?> loadClass(String name) throws ClassNotFoundException`：加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNotFoundException异常。该方法中的逻辑就是双亲委派模式的实现

* `protected Class<?> findClass(String name) throws ClassNotFoundException`：查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，徐璈自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用

  ![image-20231221234557486](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312212345951.png)

* `protectd final Class<?> defineClass(String name,byte[] b,int off,int len)`：根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有子啊自定义ClassLoader子类中可以使用

  ![image-20231221235011342](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312212350535.png)

*  `protect final void resolveClass(Class<?> c)`：复制指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说连接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用
* `protect final Class<?> findLoadedClass(String name)`：查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。
* `private final ClassLoader parent`：它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求教育自己的双亲处理

### 4.3 SecureCLassLoader与URLClassLoader

* 接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我么不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联
* 前面说过ClassLoader是一个抽象类，很多方法是空的没哟实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方法，是自定义类加载器编写更加简洁 

### 4.4 ExtClassLoader与AppClassLoader

* 了解完URLClassLoader后接着看看剩余的两个类加载器，即扩展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承URL自URLClassLoader，是sun.misc.Launcher的静态内部类。sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的
* 我们发现ExtClassLoader并没有重写loadClass()方法，这足以说明其遵守双亲委派机制。而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。

### 4.5 Class.forName()与ClassLoader.loadCla ss()

* Class.forName()：是一个静态，最常用的是Class.forName(String className)；根据传入的类的全限定名返回一个Class对象。该方法在将Class文件文件加载到内存的同时，会执行类的初始化。如：Class.forName("com.smc.java.HelloWorld")
* ClassLoader.loadClass()：这是一个实例方法，需要一个ClassLoader对象来调用该方法，该方法将Class文件加载到内存时，并不会执行类的初始化，知道这个类第一次使用时才进行初始化。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载，如：ClassLoader c1=......；cl.loadClass("com.smc.java.HelloWorld")

## 5、双亲委派模型

### 5.1 定义与本质

* 定义：如果一个类加载器在街道加载类的请求是，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，一次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载

* 本质：规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载

  ![image-20231222002306347](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312220023797.png)

### 5.2 优势与劣势

#### 5.2.1 双亲委派机制优势

* 避免类的重复加载，确保一个类的全局唯一性
  * 避免类随着他的类加载器一起具备了一种带优先级的层次关系，通过这种层级关系可以避免重复加载，当父亲已经了该类时，就没有必要子ClassLoader再加载一次
* 保护程序安全，方盒子核心API被随意篡改

#### 5.2.2 代码支持

![image-20231222003759736](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312220037954.png)

#### 5.2.3 思考

 ![image-20231222004024384](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312220040680.png)

#### 5.2.4 双亲委托模式的弊端

* 检查类是否加兹安的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。
* 通常情况下，启动类加载的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供一个接口，该接口需要再应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这是，就会出现该工厂方法无法创建由应用类加载器加载的应用实例问题

#### 5.2.5 结论

![image-20231222004813314](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312220048645.png)

### 5.2 破坏双亲委派机制

#### 5.2.1 第一次破坏双亲委派机制

* 双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器的实现方式
* 在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，知道Java模块化出现位置，双亲委派模型主要出现过3次大规模“被破坏”的情况
* 第一次破坏双亲委派机制：
  * 双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前-即JDK 1.2面世以前的“远古时代”
  * 由于双亲委派模型在JDK 1.2 之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容一些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2 之后的java.lang.ClassLoader添加一个新的protected方法findClass().并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这个里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证写出来的类加载器是符合双亲委派规则的。

#### 5.2.2 第二次破坏双亲委派机制：线程上下文类加载器

* 双亲委派模型的第一次”被破坏“是由这个模型自身的缺陷导致的，双亲委派机制很好的解决了各个加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类之所以被称为”基础“，是因为他们总是作为被用户代码继承、调用的API存在，但是程序设计往往没有绝对不变的完美规则，如果由基础类型又要调用会用户的代码，那该怎么办?

![image-20231223145540937](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312231455163.png)

* 为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器
* 有了线程的上下文类加载器，程序就可以做一些”舞弊“的事情了，JNDI服务使用了这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载器的行为，这种行为实际上是打通了双亲委派模型的层级结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但是无可奈何的事情。Java总设计SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和HBI等。不过当SPI的服务提供者多于一个的是好，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种不优雅的实现方法，在JDK 6时，JDK提供了`java.util.ServiceLoader`类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案

![image-20231223150407196](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312231504590.png)

* 默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，试的启动类加载器中的代码也可以访问应用类加载器中的类

#### 5.2.3 第三次破坏双亲委派机制

* 双亲委派模型的第三次”被破坏“是由于用户堆成需动态性的追求导致的。比如：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等

![image-20231223152726791](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312231527283.png)

* 当收到类加载请求是，OSGI将按照下面的顺序进行类搜索
  * 将java.*开头的类，委派给父类加载器加载
  * 否则，将委派列表名单中的类，委派给父类加载器加载。
  * 否则，将Import列表中类，委派该Export这个类的Bundle的类加载器加载
  * 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载
  * 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载
  * 否则，查找Dynamic Import列表的Bundle，委派给对应的Bundle的类加载器加载
  * 否则，类查找失败
  * 说明：只有两头两点任然符合双亲委派模型，其余的类查找都是在评级的类加载器中进行

#### 5.2.4 小结

* 这里，我们使用了”被破坏“这个词来形容上述不符合双亲委派模型原则的行为，但这里”被破坏“并不一定是带有贬义的。只要有明确的目的和充分的理由，突破就有原则无疑是一种创新

###  5.3 热替换的实现

* 热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统中。基本上大部分脚本语言都是天生支持热替换的。比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器

* 但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader
* 注意：有不同ClassLoader加载的同名类属于不同的累心个，不能相互转换和兼容。即两个不同的CLassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的

![image-20231223154031887](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312231540161.png)

## 6、沙箱安全机制

* 沙箱安全机制
  * 保证程序安全
  * 保护Java原生的JDK代码
* Java安全模型的核心就是Java沙箱（sndbox）。什么是沙箱？沙箱是一个限制程序运行的环境
* 沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏
* 沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样
* 所有的Java程序运行都可以指定沙箱，可以定制安全策略

### 6.1 JDK1.0时期

![image-20231223155032793](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312231550977.png)

### 6.2 JDK 1.2 时期

![image-20231223155128152](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312231551334.png)

### 6.3 JDK1.2 时期

* 在Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或者远程代码，都会按照用户的安全策略设定，由类加载器找到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制

![image-20231223155326969](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312231553205.png)

### 6.4 JDK1.6时期

![image-20231223155409047](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312231554631.png)

## 7、自定义类加载器

### 7.1 为什么要自定义类加载器?

* 隔离加载类：在某些框架内进行中间件与应用的模块，把类加载不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用依赖的jar包不会影响到中间件运行时使用的jar包。再比如：Tomcat这类web应用服务器，内部自定义了好几种类加载器，用于隔离同一个web应用服务器上的不同应用程序。
* 修改类加载的方式：类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际实际情况再某个事件点进行按需进行动态加载
* 扩展加载源：比如从数据库、网络、甚至是电视机机顶盒进行加载

* 防止源码泄漏：Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码

### 7.2 常见的场景

* 实现类似进程内隔离，类加载器实际上用做不同的命名空间，已提供类似容器、模块化效果。例如，两个模块依赖于某个类库的不同版本，如果分别不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE和OSGI，JPMS等框架
* 应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操作字节码，动态修改或者生成类型

### 7.3 注意

* 一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常

### 7.4 实现方式

* 用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑

#### 7.4.1 实现方式

* Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该集成ClassLoader类
* 在自定义ClassLoader的子类时候，我们常见会有两种做法
  * 方式一：重写loadClass()方法
  * 方式二：重写findClass()方法--推荐写法

#### 7.4.2 对比

* 这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()内部逻辑。建议的做法是在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用
  * loadClass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定框架。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择
  * 当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作

#### 7.4.3 说明

* 其父类加载器是系统类加载器
* JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口（自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外），连JDK的核心库也不能例外

## 8、Java9新特性

* 为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动

1. 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取

   * JDK9 时基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就已天然的满足了可扩展的需求，那自然无需在保留ext目录，此前使用这个目录或者java。ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了

2. 平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader

   * 现在启动类加载、平台类加载器、应用程序类加载器全都继承与`jdk.internal.loader.builtinClassLoader`

   ![image-20231223164247466](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312231642681.png)

   * 如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃

3. 在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用

4. 启动类加载器现在是在jvm内部和Java类库共同协作实现的类加载器（以前是c++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例

5. 类加载的委派关系也发生了变化

   * 当平台及应用程序类加载器收到加载请求，在委派给父加载器前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这个样的归属关系，就要优先委派给负责那个模块的加载器完成加载

   ![image-20231223165431915](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312231654027.png)

   

