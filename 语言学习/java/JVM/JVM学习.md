# 一、JVM与Java体系结构

## 1、前言

<img src="https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307042353759.png" alt="image-20230704235327581" style="zoom:50%;" />

 

### 1.1 虚拟机与Java虚拟机

* 所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。他是一款软件。用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机
  * 大名鼎鼎的Visual Box，VMware就属于系统虚拟机，他们完全是完全是对物理计算机的仿真，提供了一个可运行完整的操作系统的软件平台
  * 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机执行的指令我们称为Java字节码指令
* 无论是系统虚拟机还是程序虚拟机，在上面运行的软件被限制于虚拟机提供的资源中
* Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成
* JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器
* Java技术的核心就是Java虚拟机（JVM，Java，Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。
* 作用：Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么操作取操作数，怎么处理操作数，处理结果放在哪里
* 特点
  * 一次编译，导出运行
  * 自动内存管理
  * 自动垃圾回收管理

### 1.2 JVM的整体结构

* HotSpot VM是目前是卖弄上高性能虚拟机的代表作之一
* 它采用逛街时期与即时编译器并存的架构

<img src="https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307050046466.png" alt="image-20230705004616381" style="zoom:80%;" />

### 1.3 Java代码执行流程

<img src="https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307050053554.png" alt="image-20230705005349466" style="zoom:80%;" />

### 1.4 JVM的机构模型

* Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构
* 这两种机构之间的区别
  * 基于栈式机构的特点
    * 设计和实现更简单，适用于资源受限的系统
    * 避开了寄存器的分配难题：使用零地址指令方式分配
    * 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
    * 不需要硬件支持，可移植性更好，更好实现跨平台
  * 基于寄存器架构的特点
    * 典型的应用是x86的二进制指令集；比如传统的PC以及Android的Davlik虚拟机
    * 指令集架构则完全依赖硬件，可移植性差
    * 性能优秀和执行更高效
    * 花费更少的指令去完成一项操作
    * 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主

### 1.5 JVM的生命周期

#### 1）虚拟机的启动

* Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是虚拟机的具体实现指定的

#### 2）虚拟机的执行

* 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序
* 程序开始执行时它才会执行，程序结束时他就停止。
* 执行一个所谓的Java程序的时候，真真正正在执行一个叫做Java虚拟机的进程

#### 3）虚拟机的退出

* 有如下几种情况
  * 程序正常执行结束
  * 程序在执行过程中遇到异常或错误而异常终止
  * 由于操作系统出现错误而导致Java虚拟机进程终止
  * 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作
  * 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况

# 二、类加载子系统

 ![image-20230706000948018](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307060009105.png)

## 1、类加载器与类的加载过程

### 1.1 类加载器子系统的作用

* 类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识
* ClassLoader只负责class文件的加载，至于它是否可以运行，则有ExecutionEngine决定
* 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区还中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）

### 1.2 类加载ClassLoader角色

* class file 存在与本地硬盘上，可以理解为设计师画在为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例
* class file加载到JVM中，被称为DNA元数据模板，放在方法区
* 在.class文件→JVM→最终成为元数据模板，此过程就要一个运输工具（类加载器Class Loader），扮演一个快递员的角色

### 1.3 类加载过程

![image-20230706002703278](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307060027435.png)![image-20230706002719439](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307060027546.png)

#### 1）加载

* 通过一个类的全限定名获取定义此类的二进制字节流
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结果
* 在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口

* 加载.class的方式
  * 从本地系统中直接加载
  * 通过网络获取，典型常见：Web Applet
  * 从zip压缩包中读取，称为日后jar、war格式的基础
  * 运行时计算生成，使用最多的是：动态代理技术
  * 有其他文件生成，典型场景：JSP应用
  * 从专有数据库中提取.class文件，比较少见
  * 从加密文件中获取，典型的防Class文件被反编译的保护措施

> 反编译：Javap -v 文件名.class

#### 2）LINK：验证（Verify）

* 目的在于确保class文件的字节流中包含信息复合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
* 主要包括四种验证
  * 文件格式验证
  * 元数据验证
  * 字节码验证
  * 符号引用验证

#### 3）LINK：准备（Prepare）

* 为类变量分配内存并且设置该类变量的默认初始值，即零值
* 这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化
* 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中

#### 4）LINK：解析（Resolve）

* 将常量池内的符号引用转换为直接引用的过程
* 事实上，解析操作往往会伴随着JVM的执行完初始化之后再执行
* 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
* 解析动作主要针对类或接口、字段、类方法、接口方法、类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_FIELDREF_INFO\CONSTATN_MEthodref_info等

#### 5）初始化

* 初始化阶段就是指令类的构造器方法\<clinit\>()过程
* 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
* 构造器方法中指令按语句在源文件中出现的顺序执行
* \<clint>()不同于类的构造器。（关联LG偶在起是虚拟机视角下的\<init\>())
* 若该类具有父类，JVM会保证子类的\<clinit\>()执行前，父类的\<clinit\>()已经执行完毕
* 虚拟机必须保证一个类的\<clinit\>()方法在多线程下被同步加锁

### 1.4 类加载器的分类

* JVM支持两种类型的类加载其，分别为引导类加载器（Bootstrap ClassderLoader）和自定义类加载器（User-Defined ClassLoader）
* 从概念上来讲，自定义类加载器一般指的是程序中有开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是讲所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器
* 无论类加载器的类型如何划分，在程序中我们最常见的类加载器时钟只有三个，如下所示：

![image-20230707003825852](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307070038009.png)

* 这里四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系

```java
//获取系统类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2
ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
System.out.println(systemClassLoader);

//获取其上次能：扩展类加载器：sun.misc.Launcher$ExtClassLoader@5aaa6d82
ClassLoader extClassLoader = systemClassLoader.getParent();
System.out.println(extClassLoader);

//获取其上层：null
ClassLoader bootstrapClassLoader = extClassLoader.getParent();
System.out.println(bootstrapClassLoader);

//对于用户自定义类来说：默认使用系统该类加载器进行加载：sun.misc.Launcher$AppClassLoader@18b4aac2
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
System.out.println(classLoader);

//String类使用引导类进行加载。-->Java核心类库都是使用引导类加载器进行加载：null
ClassLoader classLoader1 = String.class.getClassLoader();
System.out.println(classLoader1);
```

#### 1）虚拟机自带的加载器

* 启动类加载器（引导类加载器，Bootstrap ClassLoader）
  * 这类加载使用C/C++语言实现的，嵌套在JVM内部
  * 它用来加载Jva的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类
  * 并不继承java.lang.ClassLoader，没有父加载器
  * 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
  * 出于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类
* 扩展类加载器（Extension ClassLoader）、
  * Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
  * 派生于ClassLoader类
  * 父类加载器为启动类加载器
  * 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载
* 应用程序类加载器（系统类加载器，AppClassLoader）
  * java语言编写，有sun.misc.Launcher$AppClassLoader实现
  * 派生于ClassLoader类
  * 父类加载器为扩展类加载器
  * 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
  * 该类加载是程序中默认的类加载器，一般爱说，Java应用的类都是由它来完成加载
  * 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器

#### 2）用户自定义类加载器

* 在Java的日常应用程序开发中，类的加载几乎是由上述3中类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式
* 为什么要自定义类加载器
  * 隔离加载类
  * 修改类加载的方式
  * 扩展加载源
  * 防止源码泄露 
* 用户自定义类加载器实现步骤
  * 开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求
  * 在JDK1.2之前，在定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载器，但是在JDK1.2之后已不在建议用户区覆盖loadClass()方法，而是建议把自定义的类加载逻辑卸载findClass()方法中
  * 在编写自定义类加载器是，如果没有泰国与复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁

### 1.5 ClassLoader

* ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）

![image-20230707014245359](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307070142496.png)

![image-20230707014326478](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307070143643.png)

* 获取ClassLoader方式

  * 获取当前类的ClassLoader

    ```java
    try {
      ClassLoader classLoader = Class.forName("java.lang.String").getClassLoader();
      System.out.println(classLoader);
    } catch (ClassNotFoundException e) {
      e.printStackTrace();
    }
    ```

  * 获取当前线程上下文的ClassLoader

    ```java
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    System.out.println(contextClassLoader);
    ```

  * 获取当前系统的ClassLoader

    ```java
    ClassLoader parent = ClassLoader.getSystemClassLoader().getParent();
    System.out.println(parent);
    ```

  * 获取调用者的ClassLoader

    ```java
    DriverManager
    ```

## 2、双亲委派机制

* Java虚拟机对class文件采用的是按需加载的方式，也就是说当时需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式

### 2.1 工作原理

* 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父亲的加载器去执行
* 如果父类加载器还存在其父类加载器，则进一步向上委托，一次递归，请求最终将到达顶层的启动类加载器
* 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式

### 2.2 优势

* 避免类的重复加载
* 保护程序安全，防止核心API被随意篡改

### 2.3 沙箱安全机制

* 自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中的java/lang/String.class)，报错信息说没有main方法就是因为加载的是rt.jar中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制

## 3、其他

* 在JVM中表示两个class对象是否为同一个类存在两个必要条件
  * 类的完整类名必须一致，包括包名
  * 加载这个累的ClassLoader必须相同
* 换句话说，在JVM中，即时这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这个两个类对象也是不相等的。

### 3.1 对类加载器的引用

* JVM必须直到一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个恶类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这连个类型的类加载器是相同的。

### 3.2 类的主动使用和被动使用

* 主动使用个，又分为七种情况
  * 创建类的实例
  * 访问某个类或接口的静态变量，或者对该静态变量赋值
  * 调用类的静态方法
  * 反射
  * 初始化一个类的子类
  * Java虚拟机启动是被标明启动类的类
  * JDK7开始提供的动态语言支持
* 除了以上七种情况，其他使用Java类的方式都被看做是对类的被动使用，都会导致类的初始化

# 三、运行时数据区的概述及线程

![image-20230711005401348](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307110054608.png)

## 1、运行时数据区内部结构

* 内存是非常重要的资源，是硬盘和CPU的中间仓库和桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局
* Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动和创建，随着虚拟机退出而销毁。另外一些则是与线程意义一一对应的，这写于线程对应的数据区域会随着开始和结束而创建和销毁
* 灰色的为单独线程私有的，红色的为多个线程共享的机
  * 每个线程：独立包括程序计数器、栈、本地栈
  * 线程间共享：堆、对外内存
* 每个JVM只有一个Runtime实例，即为运行时环境

## 2、线程

* 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行执行
* 在Hotspot JVM里，每个线程都与操作系统的本地线程映射。
  * 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收
* 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地初始化成功，它就会调用Java线程中的run()方法。
* 如果你使用jconsole或者任何一个调试工具，都能看到在后台有许多线程的运行。这些后台线程不包括调用public void main(String[])的main线程以所有这个main自己创建的线程
* 这些主要的后台系统线程在Hotspot JVM里主要是以下几个
  * 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样对才不会变化。这种线程的执行类型包括"stop-the-world"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销
  * 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性的操作的调度执行
  * GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持
  * 编译线程：这种线程在运行时会将字节码编译成到本地代码
  * 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。

## 3、程序计数器（PC寄存器）

### 3.1 PC Register介绍

![image-20230718000344223](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307180003307.png)

* JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行

* 这里并非广义上所指的物理寄存器，获取将其防疫为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟

* 作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条

  <img src="https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307172356267.png" alt="image-20230717235619116" style="zoom:80%;" />

* 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域

* 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致

* 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值

* 它是程序控制流的指示器，分支、循环就、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成

* 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

* 它是唯一一个在Java虚拟机规范中没有规定任何OutMemoreError情况的区域 

### 3.2 举例说明

![image-20230718000918422](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307180009497.png)

### 3.3 两个常见问题

* 使用PC寄存器存储字节码指令地址有什么用？
* 为什么使用PC寄存器记录当前线程的执行地址呢？
  * 因为CPU需要不停的各个线程，这时候切换回来以后，就得直到接着从哪开始继续执行。
  * JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
* PC寄存器为甚没回被设定为线程私有？
  * 我们都知道所谓的多线程在一个特定的时间段内只会执行某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫不差？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况
  * 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核理器中的一个内核，只会执行某个线程中的一条指令
  * 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。



## 4、虚拟机栈

### 4.1 虚拟机栈概述

* 虚拟机出现的背景

  * 由于跨平台的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器
  * 优点是跨平台，指令集小，编译器容易实现，缺点是性能下载，实现同样的功能需要更多的指令

* 内存中的栈和堆

  * 栈式运行时的单位，而堆是存储的单位
  * 即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放在哪

  ![image-20230718003154289](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307180031380.png)

* 虚拟机栈基本内容

  * Java虚拟机栈是什么

    * Java虚拟机栈（Java Virtual Machine Stack）,早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用
    * 是线程私有的

  * 生命周期

    * 生命周期和线程一致

  * 作用

    * 主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回
    * 局部变量 VS 成员变量（或属性）
    * 基本数据类型 VS 引用类型变量（类、数组、接口）

  * 栈的特点

    * 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
    * JVM直接对Java栈的操作只有两个：
      * 每个方法执行，伴随着进栈（入栈、压栈）
      * 执行结束后的出栈工作
    * 对于栈来说不存在垃圾回收问题

  * 开发中可能出现的异常

    * Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的
      * 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常
      * 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存区创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常

  * 设置栈内存大小

    * 我们可以使用-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

    ```java
    public class StackOverErrorMain {
        public static  int count =1;
        public static void main(String[] args) {
            count++;
            System.out.println(count);
            main(args);
    
        }
    }
    
    ```

    

    ![image-20230718011006540](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307180110643.png)

### 4.2 栈的存储单位

#### 1）栈中存储什么

* 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在
* 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）
* 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

#### 2）栈运行原理

* JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/”后进先出“原则
* 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame）,与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）
* 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
* 如果在该方法中调用了其他方法，对应的新额度栈帧就会被创建出来，放在栈的顶端，变成新的 当前栈
* 不同线程中包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。
* 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新称为当前栈帧
* Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出

#### 4）栈帧的内部结构

* 每个栈帧中存储着

  * 局部变量表（Local Variables）
  * 操作数栈（Operand Stack）（或表达式栈）
  * 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
  * 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）
  * 一些附加信息

  ![image-20230719004228241](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307190042308.png)

### 4.3 局部变量表（local variables）

* 局部变量表也被称之为局部变量数组或本地变量表
* 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型
* 由于局部变量表式建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题
* 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local varialbe数据项中。在方法运行期间是不会改变局部变量表的大小。
* 方法嵌套调用次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，是的局部变量表膨胀，它的栈帧就越大，以满足方法调用所需床底的信息增大的需求。进而函数调用就会占用更多的空间，导致其嵌套调用次数就会减少。
* 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁

#### 1）关于Slot的理解

* 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束
* 局部变量表，最基本的存储单元是Slot（变量槽）
* 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量
* 在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot
  * byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true
  * long和double则占据两个Slot
* JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
* 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序背复制到局部变量表中的每一个Slot上
* 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）
* 如果当前帧是有构造方法或者实例方法创建的，那么该对象引用this将会存放在index位0的slot处，其余的参数按照参数表顺序继续排列
* Slot的重复利用:栈帧中的局部变量表中的槽位是可以重用的，入股哦一个就不变量过了其作用域，那么在其作用域之后申明的心得局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的

#### 2）静态变量与局部变量的对比

* 变量的分类
  * 按照数据类型分
    * 基本数据类型
    * 引用数据类型
  * 按照声明的位置分
    * 成员变量：在使用前，都经历过默认初始化赋值
      * 类变量：linking的prepare阶段：给类变量默认赋值→initial阶段：给类变量显式赋值即静态代码块赋值
      * 实例变量：随着对象的赋值，会在堆空间中分配实例变量空间，并进行默认赋值
    * 局部变量
* 补充说明
  * 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递
  * 局部变量表中的变量也是重要的垃圾回收根结点，只要被局部变量表中直接或间接引用的对象都不会被回收。

### 4.4 操作数栈（Operand Stack）

* 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以称之为表达式栈
* 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈
  * 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈
  * 比如：执行复制、交换、求和等操作

* 操作数栈，主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间
* 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之创建出来，这个方法的操作数栈是空的。
* 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值
* 栈中任何一个元素都是可以任意的Java数据类型
  * 32bit的类型占用一个栈单位深度
  * 64bit的类型占用两个栈单位深度
* 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问
* 如果被调用的方法带有返回值的话，其返回值江北压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令
* 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证
* 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈

### 4.5 代码追踪

### 4.6 栈顶缓存技术（Top-of-Stack-Cashing）

* 前面提过，基于栈式架构的虚拟及所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派次数和内存读/写次数
* 由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在屋里CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率

### 4.7 动态链接（或指向运行时常量池的方法引用）

* 每一个栈帧内部都含有指向运行时常量池中概栈帧所属方法的引用。包含这个额引用的目的就是为了支持当前方法的代码能够实现动态链接。比如：invokedynamic指令
* 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用 
* 为什么需要常量池？
  * 常量池的作用，就是为了提供一些符号和常量，便于指令的识别

### 4.8 方法的调用：解析与分派

* 在JVM中，将符号引用转换为调用的方法的直接引用与方法的绑定机制相关
* 静态链接
  * 当一个字节码文件被装载JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下调用方法的符号引用转换为直接引用的过程称之为静态链接
* 动态链接
  * 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接

* 对应的方法的绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次
  * 早期绑定：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样依赖，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用
  * 晚期绑定：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。

#### 1）虚方法和非虚方法

* 非虚方法
  * 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法
  * 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法
  * 其他方法称为虚方法

#### 2）虚拟机中提供了以下几条方法调用指令：

* 普通调用指令：
  * invokestatic：调用静态方法，解析阶段确定唯一方法版本
  * invokespecial：调用\<init\>方法，私有及父类方法，解析阶段确定唯一方法版本
  * invokevirtual：调用所有虚方法
  * invokeinterface：调用接口方法
* 动态调用指令：
  * invokdynamic：动态解析出需要调用的方法，然后执行

* 前四条指令固话在虚拟机内部，方法的调用指令不可人为干预，而invokedynamic指令则支持有用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。

#### 3）关于invokedynamic指令

* JVM字节码指令集一直比较稳定，一直到Java7中增加了一个invokedynamic指令，这是Java位了实现【动态类型语言】支持而做的一种改进
* 但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式
* Java7中增加的动态语言类型的支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器

#### 4）动态类型语言和静态语言

* 动态类型语言和静态类型语言两者的区别在于对类型的检查实在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言
* 说的在直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征

#### 5）方法重写的本质

* 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C

* 如果在过程结束；如果不通类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过，则返回java.lan.IllegalAccessError异常

* 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程

* 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常

* IllegalAccessError介绍：程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有访问权限。一般的，这个会引起编译器的异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变

* 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表(virtual method table)（非虚方法不会出现在表中）来实现。使用索引表来代替查找

* 每个类中都有一个虚方法表，表中存放着各个方法的实际入口

* 那么虚方法表什么时候创建？

  * 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完成 

  ![image-20230724232928710](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307242329953.png)

### 4.9 方法返回地址

* 存放调用该方法的pc寄存器的值
* 一个方法的结束，有两种方式：
  * 正常执行完成
  * 出现未处理的异常，非正常退出
* 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出时，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息
* 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要回复上层方法的局部变量表，操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去
* 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值 

### 4.10 一些附加信息

* 调试信息

### 4.11 栈的相关面试题

## 5、本地方法接口

![image-20230725000720129](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307250007328.png)

###  5.1 什么是本地方法

* 简单地讲,一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法；该方法的视线有非Java语言实现，比如C。这个特征并非Java所特有，很多其他的编程语言都有这一进制
* 在定义一个native method 是，并不提供实现体（有些像顶一个java interface），因为其实现体是由非java语言在外面实现的
* 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合c/c++的

### 5.2 为什么使用Native Method

* Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意，为题就来了
* 与Java环境外交互
  * 有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统个，如果操作系统或某些硬件交换信息时的情况。本地方法正式这样一种交流机制：它与我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节

* 与操作系统交互
  * JVM支持者Java语言本身和运行时库，它是Java程序来意生存的平台，它由一个解释器（解释字节码）和一些链接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统尝尝是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre与底层系统的交互，设置JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法
* Sun's Java
  * Sun的解释器是用C实现的，这使得它能像一些普通的c一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类的本地方法setPriority0()。这个本地方法使用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority（） API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库提供，然后被JVM调用
* 现状
  * 目前该方法使用的越来越少了，除非是与硬件有关的应用。比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域简的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等

## 6、本地方法栈

![image-20230725003036831](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202307250030971.png)

* Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
* 本地方法栈也是线程私有的。
* 允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）
* 本地方法栈是使用C语言实现的
* 它的具体做法是Native Method Stack登记native方法，在Execution Engine执行时加载本地方法库
* 当某个线程调用一个本地方法时，它就进入了一个全新的并且不在受虚拟机限制的世界。它和虚拟机拥有同样的权限
  * 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
  * 它甚至可以直接使用跟本地处理器中的寄存器
  * 直接从本地内存的堆中分配任意数量的内存
* 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确妖气本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈
* 在Hotspot JVM中，直接诶将本地方法栈和虚拟机栈合二为一

# 四、堆

## 1、堆的核心概念

![image-20230821230335347](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308212303565.png)

* 一个JVM进程只有一个方法区和堆，进程中所有线程共享，

* 一个进程有多个线程，一个线程有一个程序计数器、本地方法栈、和虚拟机栈

* Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间

  * 堆内存的大小是可以调节的

* 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的

* 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区

* 所有的对象实例以及数组都应当在运行时分配在堆上

  * ***几乎***所有对象都分配在堆上

* 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置

  <img src="https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308212329338.png" alt="image-20230821232934159" style="zoom:50%;" />

* 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除

* 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域

* 内存细分：现代垃圾收集器大部分都给予分带手机理论设计，堆空间细分为：

  * Java7及之前堆内存逻辑分为三部分：新生区+养老区+永久区
  * Java8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间
  * 约定：新生区↔新生代↔年轻代，养老区↔老年区↔老年代，永久区↔永久代

## 2、设置堆内存大小与OOM

* Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项“-Xmx”和“-Xms”来进行设置

  * “-Xms”用于表示堆区内的其实内存，等价与-XX:InitialHeapSize
  * "-Xmx"则用于表示堆区内的最大内存，等价与-XX:MaxHeapSize

* 一旦堆区中的内存大小超过"-Xmx"所指定的最大内存时，将会抛出OutOfMemoryError异常

* 通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完兑取后不需要重新分割计算堆区的大小，从而提高性能

* 默认情况下

  * 初始内存大小：物理电脑内存大小/64
  * 最大内存大小：物理电脑内存大小/4

* 查看设置的参数：

  ```shell
  smc@linjianguodeMacBook-Pro java % jps      
  41369 Main
  42874 Launcher
  40971 
  42875 HeapSpaceInitial
  42877 Jps
  smc@linjianguodeMacBook-Pro java % jstat -gc 42875
   S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
  25600.0 25600.0  0.0    0.0   153600.0  9216.1   409600.0     0.0     4480.0 791.8  384.0   76.6       0    0.000   0      0.000    0.000
  ```

​		` -XX:+PringGCDetails打印堆GC具体信息`

* OutOfMemory具体实例

  ```java
  public class OOMTest {
      public static void main(String[] args) {
          ArrayList list =new ArrayList();
          while (true){
              try {
                  Thread.sleep(20);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              list.add(new Picture(new Random().nextInt(1024*1024)));
          }
      }
  }
  class Picture{
      private byte[] pixels;
      public Picture(int size){
          this.pixels=new byte[size];
      }
  }
  ```

  ![image-20230822001537023](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308220015092.png)

## 3、年轻代与老年代

* 存储在JVM中的Java对象可以被划分为两类

  * 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  * 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致

* Java堆区进一步细分的话，可以划分为年代（YoungGen）和老年代（OldGen）

* 其中年轻代又可以划分为Eden空间、Servivor0空间和Survivor1空间（有时可以叫做from区、to区）

  ![image-20230822230404447](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308222304576.png)

* 配置新生代与老年代在堆结构的占比

  * 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
  * 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5

* 在HotSpot中，Eden空间和两个Survior空间缺省所占的比例是6:1:1

* 当然所有开发人员可以通过选项"-XX:SurvivorRatio"调整这个空间比例。比如：-XX:SurvivorRatio=8

* 几乎所有的Java对象都是在Eden区被new出来的

* 绝大部分的Java对象的销毁都是新生代进行的

  * IBM公司专门研究标明，新生代中80%的意向都是"朝生夕死"的

* 可以使用选项"-Xmn"设置新生代最大内存大小

  * 这个参数一般使用默认值就可以了

## 4、图解对象分配过程

* 为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且有哦与内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片

1. new的对象先放在伊甸园区。此区有大小限制。
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不在被其他对象所引用的对象进行销毁。在加载新的对象放到伊甸园区
3. 然后将伊甸园区中的剩余对象移动到幸存者0区
4. 如果再次出发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区
6. 啥时候能去养老区呢？可以设置次数，默认是15次
   * 可以设置参数：-XX:MaxTenuringThreshold=N进行设置
7. 在养老区，相对悠闲。当养老区内存不足时，再次出发GC：Major GC，进行养老区的内存清理
8. 若养老区执行Major GC之后发现依然无法进行对象的保存，就会产生OOM异常

![image-20230823000051216](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308230000350.png)

## 5、Minor GC、Major GC、Full GC

* JVM进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分回收的都是指新生代
* 针对HotSpot VM的视线，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）
* 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：
  * 新生代收集（Minor GC/Young GC）:只是新生代（Eden、S0、S1）的垃圾收集
  * 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集
    * 目前，只有CMS GC会有单独收集老年代的行为
    * 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收
  * 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
    * 目前，只有G1 GC会有这种行为
  * 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集
* 年轻代GC（Minor GC）触发机制
  * 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满 不会引发GC。（每次Minor GC会清理年轻代的内存）
  * 因为，Java对象大多都具备朝生夕死的特性，所以Minor GC非常频繁，，一般会后速度也比较快。这已定义既清晰又易于理解
  * Minor GC会引发STM，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行
* 老年代GC（Major GC/Full GC）触发机制：
  * 指发生在老年代的GC，对象从老年代消失时，我们说”Major GC“或”Full GC“发生。
  * 出现Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge 收集器的收集策略里就有直接进行Major GC的策略选择过程）
    * 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC
  * Major GC速度一般会比Minor GC慢10倍以上，STW的时间更长
  * 如果Major GC后，内存还不足，就报OOM了。
* Full GC触发机制：触发Full GC执行的情况 有如下五种
  * 调用System.gc()时，系统建议执行Full GC，但是不必然执行
  * 老年代空间不足
  * 方法区空间不足
  * 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
  * 有Eden区、Survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
  * 说明：full gc是开发或调优中尽量要避免的。这样暂时时间会短一些

## 6、堆空间分代思想

*  为什么需要把Java堆分代？不分代就不能正常工作吗？
  * 经研究,不同对象的生命周期不同。70%-99%的对象是临时对象
    * 新生代：有Eden、两块大小相同的Survivor（又称为from/to,s0/s1）构成，to总为空
    * 老年代：存放新生代中经历多次GC仍然存活的对象
  * 其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死，如果分代的话，把新创建的对象放到某一个地方，当GC的时候先把这块存储”朝生夕死”的对象进行回收，这样就会腾出很大的空间出来

## 7、内存分配策略

* 针对不同年龄段的对象分配原则如下所示
  * 优先分配到Eden
  * 大对象直接分配到老年代
    * 尽量避免程序中出现过多的大对象
  * 长期存活的对象分配到老年代
  * 动态对象年龄判断
    * 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的兑现够可以直接进入老年代，无须等待MaxTenuringThreshold中要求的年龄
  * 空间分配担保
    * -XX:HandlePromotionFailure

## 8、为对象分配内存：TLAB

* 为什么有TLAB（Thread Local Allocation Buffer）
  * 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
  * 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
  * 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度
* 什么是TLAB？
  * 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
  * 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。
  * 据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。
* 尽管不是所有的对象实例能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
* 在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间，默认情况是开启的
* 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小
* 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。

![image-20230824002515271](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308240025487.png)

## 9、小结堆空间的参数设置

```java
package com.smc.java;

/**
 * -XX:+PrintFlagsInitial ：查看所有的参数的默认值
 * -XX:+PrintFlagsFinal ：查看所有的参数的最终值（可能会存在修改，不再是初始值）
 *  具体查看某个参数的指令：jps：查看当前运行中的进程
 *                      jinfo -flag SurvivorRatio 进程id
 * -Xms ：初始堆空间内存（默认为物理内存的1/64）
 * -Xmx ：最大堆空间内存（默认为物理内存的1/4）
 * -Xmn ：设置新生代的大小（初始值及最大值）
 * -XX:NewRation ：配置新生代与老年代在堆结构的占比
 * -XX:SurvivorRatio ：设置新生代中Eden和S0/S1空间占比
 * -XX:MaxTenuringThreshold ：设置新生代垃圾的最大年龄
 * -XX:+PrintGCDetails ：输出详细的GC处理日志
 * 打印gc简要信息：-XX:+PrintGC -verbos:gc
 * -XX:HandlePromotionFailure：是否设置空间分配担保
 *
 * @Date 2023/8/24
 * @Author smc
 * @Description:
 */
public class GCTest {
    public static void main(String[] args) {
        System.out.println("GCTest");
    }
}
```

* -XX:HandlePromotionFailure：是否设置空间分配担保
  * Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间
    * 如果大于，则此次Minor GC是安全的r
    * 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败
      * 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。
        * 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的
        * 如果小于，则改为进行一次Full GC
      * 如果HandlePromotionFailure=false，则改为进行一次Full GC
  * 在JDK7之后，HandlePromotionFailure参数不会在影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会在使用它。JDK7之后的规则变为只要老年代的可用连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。

## 10、堆是分配对象的唯一选择吗

* 在<<深入理解Java虚拟机>>中关于Java堆内存有这样一段描述：随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到对上也渐渐地变得不那么”绝对"了
* 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸处方法的话，那么就可能被优化成栈上分配。这样就无需再对上分配内存，也无需进行垃圾回收了。这也就是常见的堆外内存技术
* 此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创建的GCIH(GC invisible heap)技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，一次达到降低GC的回收频率和提升GC的回收哦效率的目的

* 逃逸分析概述

  * 如何将对上的对象分配到栈，需要使用逃逸分析手段
  * 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法
  * 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
  * 逃逸分析的基本行为就是分析对象动态作用域
    * 当一个对象子啊方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
    * 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数床底到其他地方中
  * 没有发生逃逸的对象，可以分配到栈上，随着方法执行的结束，栈空间就被移除

* 逃逸分析：代码优化

  * 栈上分配：将对分配转化为栈分配。如果一个对象子程序中被分配，要是指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配

  * 同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步

    * 线程同步的代价是相当高的，同步的后果是降低并发性和性能
    * 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候救护取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除

  * 分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

    * 标量（Scalar）是值一个无法在分解成更小的数据的数据。Java中的原始数据类型就是标量。

    * 相对的，哪些还可以分解的数据就叫聚合量(Aggregate)，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量

    * 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会吧这个额对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换

      ![image-20230824014942536](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308240149731.png)

    * 以上代码，经过标量替换后，就会变成

      ![image-20230824015023015](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308240150173.png)

    * 可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以打打减少堆内存的占用。因为一旦不需要创建对象了，那么就不在需要分配堆内存了
    * 标量替换为栈上分配提供了很好的基础
    * 标量替换参数设置:-XX:+EliminateAllocations:开启了标量替换（默认打开），允许将对象打散分配在栈上
    * 逃逸分析只有在-server模式下才能启动：-server

# 五、方法区

## 1、栈、堆、方法区的交互关系

* 运行时数据区结构图

  ![image-20230824231153207](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308242311301.png)

* 交互关系

  ![image-20230824231343407](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308242313577.png)

## 2、方法区的理解

* 《Java虚拟机规范》中明确说明："尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的视线可能不会选择区进行垃圾收集或者进行压缩。"但对于HotSpotJvm而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开
* 所以，方法区看做是一块独立于Java堆的内存空间
* 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域
* 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以使不连续的
* 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展
* 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误` OOM:PermGen space`或者` OOM:Metaspace` 
  * 加载大量的第三方的jar包
  * Tomcat部署的应用
  * 大量动态的生成反射类
* 关闭JVM就会释放这个区域的内存
* 在jdk7及之前，习惯上把方法区，称为永久代。jdk8开始，使用元空间（Metaspace）取代了永久代
* 本质上，方法区和永久代并不等价但是类似，都是对JVM规范中方法区的视线。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存，也就意味着只要本地内存足够,就不会出现OOM的错误
* 永久代、元空间二者并不只是名字变了，内部结构也调整了
* 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常

## 3、设置方法区大小与OOM

* 方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。
* jdk7及以前：
  * 通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M
  * -XX:MaxPermSize来设定永久代最大可分配空间。32位机器默认是64M。64位机器模式是82M
  * 当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space
* jdk8以后：
  * 元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MetaspaceSize指定，替代上述原有的两个参数
  * 默认值依赖于平台：windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值-1，即没有限制
  * 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError：Metaspace
  * -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不在存活），然后这个高水位线将会被重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值
  * 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁GC，建议将-XX:MetaspaceSize设置为一个相对较高的值
* 如何解决这些OOM?
  * 要解决OOM异常或heap space异常，一般的手段是首先通过内存映像分析工具对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄露(Memory Leak)还是内存溢出(Memory Overflow)
  * 如果是内存泄露，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路劲与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置
  * 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应道检查虚拟机的堆参数（-Xmx与Xms）,与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗

## 4、方法区的内部结构

![image-20230825002651287](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202308250026568.png)

* 方法区（Method Area）存储什么？
  * 它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译编译后的代码缓存
* 类型信息：堆每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
  * 这个类型的完整有效名称（全名=包名.类名）
  * 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）
  * 这个类型的修饰符（public，abstract，final的某个子集）
  * 这个类型直接接口的一个有序列表
* 域（Field）信息
  * JVM必须在方法区中保存累心给的所有域的相关信息以及域的声明顺序
  * 域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）
* 方法（Method）信息：JVM必须保存所有方法的以下信息，同域信息一眼过包括声明顺序：
  * 方法名称
  * 方法的返回类型（或void）
  * 方法参数的数量和类型（按顺序）
  * 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）
  * 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
  * 异常表（abstract和native方法除外）
    * 每个异常处理的开始位置、结束为止、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引
* non-final的类变量
  *  静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分
  * 类变量被雷的所有实例共享，即时没有类实例时你也可以访问它
* 全局常量：static final
  * 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了 
* 为什么需要常量池
  * 一个java源文件的类、接口、编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码当中，换以一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，
  * 常量池有什么
    * 数值
    * 字符串值
    * 类引用
    * 字段引用
    * 方法引用

  * 常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型

* 运行时常量池
  * 运行时常量池(Runtime Constant Pool)是方法区的一部分
  * 常量池表(Constant Pool Table)是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中
  * JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项项数组项一样，是通过索引访问的
  * 运行时常量池总包含多种不同的常量池，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址
    * 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性

  * 运行时常量池类似于创痛编程语言中的符号表（Symbol table），但是它所包含的数据却比符号表更加丰富一些
  * 当创建类或接口的运行时常量池，如果构造运行时常量池所需的内存空间超过了方法区所提供的最大值，则JVM会抛OutOfMemoryError异常


## 5、方法区使用举例

## 6、方法区的演进细节

* 首先明确：只有HotSpot才有永久代

* HotSpot中方法区的变化

  ![image-20230905235328976](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309052353151.png)

* 永久代为什么要被元空间替换
  * 在某些场景下，如果动态加载类过多，荣有产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。而元空间和永久代之间最大的去呗就是：元空间并不在虚拟机中，而是使用本地内存。因此默认情况下，元空间的大小仅受本地内存限制
  * 对永久代进行调优是很困难得
* StringTable为什么调整位置
  * Jdk7中奖StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发
  * 这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。 

## 7、方法区的垃圾回收

* 有些人任务方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范。对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有为实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）
* 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收又确实必要的。以前的Sun公司的Bug列表中，曾数显过的若干个严重的bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。
* 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型
* 判断一个常量是否“废弃”还是相对简单，而要判断一个类型是否属于“不再被使用的类”的条件比较苛刻了。需要同时满足下面三个条件：
  * 该类所有的实力都已经被回收，也就是Java堆中存在该类及其任何派生子类的实例
  * 加载该类的类加载器已经被回收了，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGI，JSP等冲冲加载等，否则通常是很难达成的
  * 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
* Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而不是和对象一样，没有引用就必然会回收。关于是否对类型进行回收，HotSpot虚拟机提供-Xnoclassgc参数进行控制，还可以使用-verbos：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnloading查看类加载和卸载信息
* 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGI这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力

## 8、总结

![IMG_962A9FC813C5-1](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311142118174.jpeg)

# 六、对象的实例化内存布局与访问定位

## 1、对象的实例化

### 1.1 创建对象的方式

![IMG_6A4A6D5A5FBD-1](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311142134577.jpeg)

### 1.2 创建对象的步骤

![IMG_D28552D332F4-1](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311142134775.jpeg)

* 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象
* 首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例化成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。
  * 如果内存是规整，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存：意思是所有用户的内存在一边，空闲的内存在一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是吧指针向空闲的那边挪动一段与对象带下相等距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact（整理）过程的收集器时，使用指针碰撞。
  * 如果内存是不规整的，已使用的内存和未使用的内存相互碰撞，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容，这种分配方式称为“空闲列表（Free List）”
  * 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
* 在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法啊，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。
* 将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息数据存储在对象的对象头中。这个过程的具体设置取决于JVM实现
* 在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把对内对象的首地址复制给引用变量。因此一般来说（由于字节码中是否跟随有invokespecial指令所决定），new指令之后会被接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。

## 2、对象的内存布局

![IMG_1719D56F9B78-1](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311142202524.jpeg)

![IMG_BFF048E152B8-1](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311142208204.jpeg)

## 3、对象的访问定位

![IMG_43D4BCC6B499-1](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311142210735.jpeg)

* JVM通过栈上reference访问其内部的对象实例

* 对象访问的方式主要有两种

  * 句柄访问

    ![IMG_C525A5CF5BD8-1](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311142212787.jpeg)

  * 直接访问（Hotspot采用）

    ![IMG_63C874E2DAAE-1](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311142213307.jpeg)

# 七、直接内存（Direct Memory）

## 1、概述

* 不是虚拟机运行时数据的一部分，也不是《Java虚拟机规范》中定义的内存区域。

* 直接内存是在Java堆外的，直接向系统申请的内存区间。

* 来源于NIO，通过存在队中的DirectByteBuffer操作Native内存内存

* 通常，访问直接内存的速度会优于Java堆。即读写性能高

  * 因此处于性能考虑，读写频繁的场合可能会考虑使用直接内存
  * Java的NIO库允许Java程序使用直接内存，用于数据缓冲区

  ![截屏 2023-11-17 20.19.36.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311172023470.png)

  ![截屏 2023-11-17 20.22.57.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311172024736.png)

* 也可能导致OutOfMemoryError异常
* 由于直接内存在Java对外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是受限的，Java堆和直接内存的总和依然受限与操作系统能给出的最大内存
* 缺点
  * 分配回收成本较高
  * 不受JVM内存回收管理
* 直接内存大小可以通过MaxDirectMemorySize设置
* 如果不指定，默认与堆的最大值-Xmx参数值一致

![截屏 2023-11-17 20.36.27.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311172037748.png)

# 八、执行引擎（Execution Engine）

![截屏 2023-11-17 20.38.45.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311172040784.png)

## 1、执行引擎概述

![截屏 2023-11-17 20.42.02.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311172042831.png)

* 执行 引擎是Java虚拟机核心的组成部分之一
* “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式
* JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息
* 那么，如果想要让一个Java程序运行起来，执行引擎的任务就是将字节码指令解释/编译为对应平台的本地机器指令才可以。简单来说，JVM的执行引擎充当了将高级语言翻译为机器语言的译者。

## 2、Java代码编译和执行过程

![](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311172057379.png)

* 执行引擎在执行过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器
* 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址
* 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息
* 从外观上来看，所有Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果

![截屏 2023-11-17 21.02.31.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311172102212.png)

* 大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤

![截屏 2023-11-17 21.05.00.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311172105868.png)

* Java代码编译是由Java源码编译器来完成

![截屏 2023-11-17 21.06.35.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311172106898.png)

* Java字节码的执行是有JVM执行引擎来完成
* 什么事解释器（Interpreter），什么是JIT编译器？
  * 解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行
  * JIT（JUST In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言
* 为什么是Java是半搬移半解释型语言？
  * JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器
  * 现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行

## 3、机器码、指令、汇编语言

* 由于指令的可读性还是太差，于是人们又发明了汇编语言，

## 4、解释器

* JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时逐行解释字节码执行程序的方法。

![截屏 2023-11-19 13.50.42.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311191351818.png)

* 解释器真正意义所承担的角色就是一个运行时“翻译者“，将字节码文件中的内容”翻译“为对应平台的本地机器指令执行
* 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行的解释操作。
* 由于解释器在设计和实现上非常简单，因此处理Java语言之外，还有许多高级语言同样也是基于解释器执行，比如Python、Perl、Ruby等，但是在今天，基于解释器执行已经沦落为抵消的代名词
* 为了解决这个这个问题，JVM平台支持一种叫做即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以是执行效率大幅度提升
* 不过无论如何，基于解释器的执行模式仍然作为中间语言的发展做出不可磨灭的功效

## 5、JIT编译器

* 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行
* 第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码再执行
* HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。

* 为什么内置了JIT编译器还保留解释器？（JRockit VM内部就不包含接地气，字节码全部都依靠及时编译器编译后执行）
  * 首先明确：当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。
  * 所以：尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看重启动时间的应用场景而言，获取就需要采用解释器与即时编译并存的架构来换取一个平衡点。在此模式下，当虚拟机启东时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后在执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码获得更高的执行效率。
  * 同时，解释执行在编译器进行激进优化不成立的时候，作为编辑器的”逃生门“

* 概念解释
  * Java语言的”编译期“其实是一段”不确定“的操作过程，因此它可以能是指一个前端编译器（其实靠谱”编译器的前端“更准确一些）把.java文件转变为.class文件的过程
  * 也可能是指虚拟机的后端运行编译期（JIT编译器）把字节码转变成机器码的过程
  * 还可能是指使用静态提起编译期（AOT编译期）直接把.java文件编译成本地机器代码的过程
* 如何选择？热点代码及探测方式
  * 当然是否需要启动JIT编译器将字节码直接编译成对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为”热点代码“，JIT编译器在运行时会针对那些频繁被调用的”热点代码“做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。
  * 一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为”热点代码“，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换OSR（On Stack Replacement）编译
  * 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些”热点代码“编译为本地机器指令执行。这里主要依靠热点探测功能
  * 目前HotSpot VM所采用的热点探测方式给予计数器的热点探测
  * 采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）
    * 方法调用计数器用于统计方法的调用次数
    * 回边计数器则用于统计循环体执行的循环次数
  * 方法调用计数器
    * 这个计数器用于统计方法被调用的次数，它的默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值就会触发JIT编译
    * 这个阈值可以通过虚拟机参数-XX:CompileThreshold来认为设定
    * 当一个方法被调用时，会先检查该方法是否被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将次方法的调用计数器值加1，然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译期请求
    * 热度衰减
      * 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计时器热度的衰减，而这段时间被称为此方法通缉的半衰周期
      * 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可是使用虚拟机参数-XX:UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行的时间足够长，绝大部分方法都会编译成本地代码。
      * 另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒
  * 回边计数器
    * 它的作用是统计一个方法循环体代码被执行了的次数，在字节码中遇到控制流向后跳转的指令称为”回边“(Back Edge)。显然，建立回边计数器统计的目的就是触发OSR编译。
* HotSpot VM设置程序执行方式
  * 缺省情况下HotSpot VM是采用解释器与即时编译器并存档额架构，当然开发人员可以根据具体的应用场景，通过命令显式地位Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行
  * -Xint：完全采用解释器模式执行程序
  * -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会接入执行
  * -Xmixed：采用解释器+即时编译器的混合模式共同执行程序
* HotSpot VM中JIT分类
  * 在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器和C2编辑器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示
  * -Client：指定Java运行在Client模式下，并使用C1编译期；C1编译期会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度
  * -Server：指定Java虚拟机运行在Server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（C++编写）

* 自JDK10起，HotSpot又加入一个全新的即时编译器：Graal编译器
* jdk9引入了AOT编译器（静态提前编译器，Ahead Of Time Compiler）
  * 最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来”第一次运行慢“的不良体验
  * 缺点
    * 破坏了java”一次编译，到处运行“，必须为每个不同的硬件、OS编译对应的发型包
    * 降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知
    * 还需继续优化中，最初只支持Linux x64 java base

# 九、StringTable

## 1、String的基本特性

* String声明为final的，不可被继承
* String实现了Serializable接口：表示字符串支持序列的
* 实现了Comparable接口：表示String可以比较大小
* String在jdk8及以前内部定义了final char[] value用于存储字符串数据。jdk9时改为byte[]
  * 节约空间
* String：代表不可变的字符序列。
  * 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
  * 当对现有的字符串进行连接操作时，也需要重新制定内存区域赋值，不能使用原有的value进行赋值。
  * 当使用String的replace()方法修改指定字符或字符串时，也需要重新制定内存区域赋值，不能使用原有的value进行赋值
* 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。
* 字符串常量池中是不会存储相同内容的字符串
  * String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表常了后直接会造成的影响就是当调用String.intern时性能会大幅下降
  * 使用-XX:StringTableSize可设置StringTable长度
  * 在jdk6中StringTableTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设置没有要求
  * 在jdk7中，StringTable的长度默认值为60013
  * jdk8中，1009是可设置的最小值
* Intern()：当字符串常量池没有该数据时，在字符串串常量池中生成

## 2、String的内存分配

* 在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使他们在运行过程过程中速度更快、更节省内存，都提供了一种常量池的概念
* 常量池类似一个Java系统级别提供的缓存。8中基本数据类型的常量池都是系统更协调的，String类型的常量池比较特殊。它的主要使用方法有两种

## 3、String的基本操作

* Java语言规范要求无安全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须指向同一个String类实例

## 4、字符串的拼接操作

* 常量与常量的拼接结果在常量池，原理是编译期优化
* 常量池中不会存在相同内容的常量
* 只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder
  * 如果拼接符号的前后出现变量，则相当于在堆空间中new String()，具体内容为拼接的结果：javaEEhadoop
  * 如果拼接字符左右两边是字符串常量或者字符串常量引用，则仍然是编译期优化
* 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址
  * intern()判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中的地址；如果字符串不存在生成对象返回地址。
* 拼接操作与append操作的效率对比
  * 通过StringBuilder的append的方式添加字符串的效率要远高于使用String的字符串拼接方式
  * StringBuilder的append()的方式：自始至终只创建过一个StringBuilder的对象
  * 使用String的字符串拼接方式：创建过多个StringBuilder和String的对象。内存中由于创建较多的StringBuilder和String的对象，内存占用更大。如果进行gc，则需要花费更多的时间。
  * 在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highlevel的情况，建议使用构造器StringBuilder(highLevel)限定长度

## 5、intern()的使用

* 如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池
* 也就是说，如果任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。
* 通俗的讲，Interned String就是确保字符串在内存中只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）
* 如何保证变量s指向字符串常量池中的数据呢？
  * String s="aaabbb";//字面量定义的方式
  * 调用intern

![截屏 2023-11-19 16.32.16.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311191632206.png)

### 5.1 面试题

![截屏 2023-11-19 16.42.48.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311191643385.png)

![截屏 2023-11-19 16.42.02.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311191643181.png)

* 总结String的intern()的使用
  * jdk1.6中，将这个字符串对象尝试放入串池
    * 如果池中有，则不会放入。返回已有的串池中的对象的地址
    * 如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址
  * Jdk1.7中，将这个字符串对象尝试放入串池
    * 如果串池中有，则不会放入，返回已有的串池中的对象的地址
    * 如果没有，则会把对象的引用地址赋值一份，放入串池，并返回串池中的引用地址
* 对于程序中大量存在的字符串，尤其其中存在大量的重复字符串是，使用intern()可以节省内存空间。

## 6、StringTable的垃圾回收

## 7、G1中的String去重操作

* 背景：对许多Java应用（有大的也有小的）做的测试得出以下结果
  * 堆存货数据集合里面String对象占25%
  * 堆存货数据集合里面重复的String对象有13.5%
  * String对象的平均长度是45
* 许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：string1.equal(string2)=true。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存
* 实现
  * 当垃圾收集器工作的时候，会访问对上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。
  * 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象
  * 使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组
  * 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉
  * 如果查找失败，char数组会被插入到hashtable，这样以后的时候可以用共享这个数组

# 十、垃圾回收的概述

## 1、什么是垃圾

* 垃圾收集，不是Java语言的半生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生
* 关于垃圾收集有三个经典问题
  * 哪些内存需要回收
  * 什么时候回收
  * 如何回收
* 垃圾收集机制是Java的招牌能力，极大的提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断地演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战。

### 1.1 什么是垃圾（Garbage）？

* 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾
* 如果不及时对内存中垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出

## 2 、为什么需要GC

* 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾从来不打扫一样
* 除了释放没用的对象，垃圾回收也可以清楚内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象
* 随着应用程序所应付的业务越来越庞大、复杂。用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化

## 3、早期垃圾回收

* 在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码

  ![image-20231123225306677](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311232253036.png)

* 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记了回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃

## 4、Java垃圾回收机制

* 自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险
  * 如果没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄漏问题让你头疼
* 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专注于业务开发

* 对于Java开发人员而言，自动内存管理就是一个黑匣子，如果过度依赖于“自动“，那么将会是一场灾难，最严重就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力
* 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速的根据错误异常日志定位问题和解决问题
* 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到最大并发量的瓶颈时，我们就必须对这些”自动化“的技术试试必要的监控和调节
* 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收
  * 其中，Java堆事垃圾收集器的工作重点
* 从次数上讲
  * 频繁收集Young区
  * 较少收集old区
  * 基本不动Perm区（或元空间）

# 十一、垃圾回收的相关算法

## 1、标记阶段

 ### 1.1 垃圾标记阶段：对象存活判断

* 在队里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中那些时存活对象，哪些是已经死亡的对象。只有被标记为已经死亡的对象，GC才会执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以成为垃圾标记阶段
* 那么在JVM中究竟如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡
* 判断对象存活一般有两种方式：引用技术算法和可达性分析算法

### 1.2 标记阶段：引用技术算法

* 引用技术算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。

* 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1，只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收

* 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性

* 缺点：

  * 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销

  * 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销

  * 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一个致命缺陷，导致在Java的垃圾回收器中没有使用这类算法

    ![image-20231123234415202](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311232344622.png)

* 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的python，它更是同事支持引用计数和垃圾收集机制
* 具体那种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试
* Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系
* Python如何解决循环引用
  * 手动解除：很好理解，就是在合适的时机，解除引用关系
  * 使用弱引用weakref，weakref是python提供的标准库，旨在解决循环引用

### 1.3 标记阶段：可达性分析算法（或跟搜索算法、追踪性垃圾收集）

* 相对于引用技术算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生

* 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫做追踪性垃圾收集（Tracing Garbage Collection）

* 所谓”GC Roots“根集合就是一组必须活跃的引用

* 基本思路

  * 可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达
  * 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接的连接着，搜索所走过的路径称为引用链（Reference Chain）
  * 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象
  * 在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象

  ![image-20231123235552593](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311232355956.png)

* GC Roots：在Java语言中，GC Roots包括以下几类元素
  * 虚拟机栈中引用的对象
    * 比如：各个线程被调用的方法中使用到的参数、局部变量等
  * 在本地方法栈内JNI（通常说的本地方法）引用的对象
  * 方法区中类静态属性引用的对象
    * 比如：Java类的引用类型静态变量
  * 方法区中常量引用的对象
    * 比如：字符串常量池（String Table）里的引用
  * 所有被同步锁synchronized持有的对象
  * Java虚拟机内部的引用
    * 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器
  * 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存
* 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象”临时性“地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）
  * 如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域时虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性
* 小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root
* 注意
  * 如果要使用可达性分析算法来判断内存式会否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证
  * 这点也是导致GC进行时必须”Stop The World“的一个重要原因
    * 即使号称（几乎）不会发生停顿的CMS收集器中，枚举根结点时也必须要停顿的

## 2、对象的finalization机制

* Java语言提供了对象的终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑
* 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法
* finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等
* 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三个：
  * 在finalize()时可能会导致对象复活
  * finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端秦光系啊，若不发生GC，则finalize()方法将没有执行机会
  * 一个糟糕的finalize()会严重影响GC的性能
* 在功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本职上不同于C++中的析构函数
* 由于finalize()方法的存在，虚拟机中的对象一般处于三种可能得状态。如果从所有根结点都哦无法访问到某个对象，说明对象已经不在使用。一般来说，此对象需要被回收。但事实上，也并非是”非死不可“的，这时候他们暂时处于”缓刑阶段“。一个无法触及的对象有可能在某一个条件下”复活“自己。如果这样，那么对它的回收就是不合理的，为此定义虚拟机的对象可能的三种状态：
  * 可触及的：从根结点开始，可以到达这个对象
  * 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活
  * 不可触及的：对线给的finalize()呗调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能背负发货，因为finalize()只会被调用一次
* 以上3中状态中，是由于finalize()方法的存在进行的区分。只有在对象不可触及时，才可以被回收。

### 2.1 具体工程

* 判定一个对象objA是否可回收，至少要经历两次标记过程：
  * 如果对象objA到GC Roots没有引用链，则进行第一次标记
  * 进行筛选，判断次对象是否有必要执行finalize()方法
    * 如果对象objA没有重写finalize()Fangfa ,或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的
    * 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建、低优先级的Finalizer线程出发其finalize()方法执行
    * finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那额在第二次标记时，objA会被移出“即将回收”的集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次

## 3、MAT与JProfiler的GC Roots溯源

* MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器，用于查找内存泄漏以及查看内存消耗情况
* MAT是基于Eclipse开发的，是一款免费的性能分析工具

### 3.1 获取dump文件

* 方式1：命令行使用jmap

  ```shell
  smc@bogon ~ % jps
  84147 Main
  86660 Jps
  86620 Launcher
  33550 
  86622 GCRootsTest
  smc@bogon ~ % jmap -dump:format=b,live,file=test1.bin 86622 
  Dumping heap to /Users/smc/test1.bin ...
  Heap dump file created
  smc@bogon ~ % jmap -dump:format=b,live,file=test2.bin 86622
  Dumping heap to /Users/smc/test2.bin ...
  Heap dump file created
  smc@bogon ~ % 
  
  ```

* 方式2：使用JVisulaVM导出，MAT查看` https://eclipse.dev/mat/`

## 4、清除阶段

* 当成功区分出内存中存货对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存
* 目前在JVM中比较常见的三种垃圾收集算法是标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compace）

### 4.1 标记-清除算法（Mark-Sweep）

* 背景：是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言
* 执行过程：当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二则是清除
  * 标记：Collector从引用根结点开始遍历，标记所有被引用的对象，一般是在对象的Header种记录为可达对象
  * 清除：Collector对对内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记可达对象，则将其回收

![截屏 2023-11-25 16.31.01.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311251632628.png)

* 缺点
  * 效率不算高
  * 在进行GC的时候，需要停止整个应用程序，导致用户体验差
  * 这种方式清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表
* 注意：何为清除
  * 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够就存放。

### 4.2 复制算法（Copying）

* 背景：为解决标记-清除算法在垃圾收集效率方面的缺陷，“使用双存储区的Lisp语言垃圾收集器CA LISP Grabage Collector Algorithm Using Serial Secondary Storage”。在该论文描述的算法被人称为“复制算法”，也成功引入到Lisp语言的一个实现版本中
* 核心思想：将活着的内存空间氛围两块，每次只使用其中一款，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收

![截屏 2023-11-25 16.39.52.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311251640003.png)

* 优点：
  * 没有标记和清除的过程，实现简单，运行高效
  * 复制过去以后保证空间的连续性，不会出现“碎片”问题
* 缺点：
  * 此算法的缺点也是很明显的，就是需要两倍的内存空间
  * 对于G1这种拆分成为大量region的GC，复制而不是移动，一位GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小
* 特别的：
  * 如果系统中的垃圾对象很多，复制算法需要复制的存储对象数量并不会太大，是比较好的。如果存活对象很多，复制算法性能就不是很理想。

### 4.3 标记-压缩（Mark-Compact）算法

* 背景：复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况再新生代经常发生，但是在老年代，更常见的情况是发部分对象都是存活的。如果依然时候复制算法，由于存活对象较多，复制成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他算法
* 标记-清除算法的确可以应用于老年代，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要再次基础上进行改进。标记-压缩由此诞生
* 执行过程
  * 第一阶段和标记-清除算法一样，从根结点开始标记所有被引用对象
  * 第二阶段将所有的存货对象压缩到内存的一端，按顺序排放
  * 之后清除边界外所有的空间

![截屏 2023-11-25 16.53.33.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311251654268.png)

* 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此也可以把它称为标记-清除-压缩算法
* 二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存档的风险决策
* 可以看到，标记的存活对象将会被整理，按照内存地址一次排序，而违背标记的内存会被清理掉。如此一来，当我们新对象分配内存是，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。
* 优点：
  * 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存是，JVM只需要持有一个内存的起始地址即可
  * 清除了复制算法当中，内存减半的高额代价
* 缺点：
  * 从效率上讲，标记-整理算法要低于复制算法
  * 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
  * 移动过程中，需要全程暂停用户应用程序，STW

### 4.4 对比三种算法

|          | Mark-Sweep         | Mark-Compact     | Copying                               |
| -------- | ------------------ | ---------------- | ------------------------------------- |
| 速度     | 中等               | 最慢             | 最快                                  |
| 空间开销 | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要货对象的2倍大小（不堆积碎片） |
| 移动对象 | 否                 | 是               | 是                                    |

### 4.5 分代收集算法

* 没有最好的算法，只有最合适的算法

![截屏 2023-11-25 17.07.28.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311251707879.png)

![截屏 2023-11-25 17.09.22.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311251709870.png)

![截屏 2023-11-25 17.10.55.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311251711846.png)

### 4.6 增量收集算法

* 上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the world的状态。在Stop the World状态，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生
* 基本思想
  * 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存，接着切换到应用程序线程。依次反复，直到垃圾收集完成
  * 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。
* 缺点：
  * 使用这种方式，由于在垃圾回收过程中，间断性执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量下降。

### 4.7 分区算法

* 一般来说，在相同条件下，堆空间越大，依次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿
* 分代算法将按照对象生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间region
* 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间

# 十二、垃圾回收相关概念

## 1、System.gc()的理解

* 在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式出发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存
* 然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用
* JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。

## 2、内存溢出与内存泄漏

### 2.1 内存溢出（OOM）

* 内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一
* 由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收一斤跟不上内存消耗的速度，否则不太容易出现OOM情况
* 大多数情况下，GC会进行各种年两端的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用
* javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。
* 首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够，愿意有二：
  * Java虚拟机的堆内存设置不够：比如可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms、-Xmx来调整
  * 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）：对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM堆永久代垃圾收集（如：常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多件，尤其是在运行时存在大量动态类型生成场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space"
  * 随着元数据区的引如，方法区内存已经不在那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：”java.lang.OutOfMemoryError:Metaspace“。直接诶内存不足，也会导致OOM
* 这里面隐含这一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所可能去清理出空间
  * 例如：在引用机制分析中，设计到JVM会去尝试回收软引用指向的对象等
  * 在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间
* 当然，也不是在任何情况下垃圾收集器都会被触发
  * 比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError

### 2.2 内存泄漏（Memory Leak）

* 也称作”存储渗漏“。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏
* 但实际情况很多时候一些不太好的实践（或疏导）会导致对象的生命周期变得很长设置导致OOM，也可以叫做宽泛意义上的”内存泄漏“
* 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃
* 注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟机内存大小取决于磁盘交换区设定的大小

![截屏 2023-11-25 18.35.00.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311251835801.png)

* 举例：
  * 单例模式：单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不可能被回收的，则会导致内存泄漏的产生
  * 一些提供close的资源未关闭导致内存泄漏：数据库连接（dataSourse.getConnection()）,网络连接（Socket）和io连接必须手动close，否则不能被回收



## 3、Stop The World

* 简称STW，指定是GC时间发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，优点像卡死的感觉，这个停顿称为STW。
  * 可达性分析算法中枚举根结点（GC Roots）会导致Java执行线程停顿
    * 分析工作必须在一个能确保一致性的快照中进行
    * 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
    * 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证
* 被STW的应用程序会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生
* STW事件和采用哪款GC无关，所有的GC都有这个事件
* 哪怕是G1也不可能完全避免STW情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能的缩短STW的时间
* STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常工作的线程全部停掉
* 开发中不要用System.gc()；会导致STW的发生

## 4、垃圾回收的并行与并发

### 4.1 并发（Concurrent）

* 在操作系统中，是指一个时间段中又哦几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行
* 并发不是真正意义上的”同时并行“，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间来回切换

### 4.2 并行（Parallel）

* 当系统有一个以上CPU时，当一个CPU执行一个进程是，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行
* 其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行
* 适合科学计算，后台处理等弱交互场景

### 4.3 垃圾回收的并发与并行

* 并发与并行，在谈论垃圾收集器的上下文语境中，他们可以解释如下
  * 并行：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。
    * 如ParNew,Parallel Scavenge、Parallel Old；
  * 串行（Serial）
    * 相对于并行的概念，单线程执行
    * 如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，在启动程序的线程
  * 并发：指用户线程与垃圾收集线程同时执行（但不一定冰的，可能交替执行），垃圾回收线程在执行时不会停顿用户程序的运行
    * 用户程序在继续运行，而垃圾收集程序线程运行在另一个CPU上
    * 如：CMS、G1

## 5、安全点与安全区域

### 5.1 安全点（Safepoint）

* 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定位置才能停顿下来开始GC，这些位置成为"安全点“。
* Safepoint的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时性能问题。大部分指令的执行时间都非常短暂，通常根据”是否具有让程序长时间执行的特征“为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等
* 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来？
  * 抢占是中断（目前没有虚拟机采用）：首先中断所有线程。如果还有线程在不安全点，就恢复线程，让线程跑到安全点
  * 主动式中断：设置一个中断标志，各个线程运行到safepoint的时候主动轮询这个标志，如果标志为真，则将自己进行中断挂起

### 5.2 安全区域

* Safepoint机制保证了程序执行时，在不太长时间内就会遇到可进入GC的Safepoint。但是程序”不执行“的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，”走“到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决
* 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的SafePoint

## 6、引用

* 我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间再进行垃圾收集后还是很紧张，则可以抛弃这些对象

![截屏 2023-11-25 19.11.19.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311251911533.png)

* Refrenence子类中只有终结器引用时包内可见的，其他3种引用类型均为public，可以在应用程序中直接引用
  * 强引用（StrongReference）：最传统的”引用“的定义，是指在程序代码之中普遍存在的引用赋值，即类似”Object obj=new Object()“这种引用关系，无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象
  * 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常
  * 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象
  * 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知

### 6.1 强引用-不回收

* 在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也就是默认的引用类型
* 挡在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向对象的一个强引用
* 强引用的对象是可触及的，垃圾收集器永远不会回收掉被引用的对象
* 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时间还是要看手机策略
* 相对的，软引用、弱引用和虚引用的对象是软可触及、弱干可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成内存泄漏的主要原因之一。

### 6.2 软引用-内存不足即回收

* 软引用是用来描述一些还有用，但非必须得对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常

* 软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存

* 垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选的引用存放到一个引用队列（Reference Queue）

* 类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理

* 在JDK 1.2 版之后同了java.lang.ref.SoftReference类实现软引用

  ![截屏 2023-11-25 19.36.20.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311251936877.png)

### 6.3 弱引用-发现即回收

* 若引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆控件使用是否充足，都会回收掉只被弱引用关联的对象
* 但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。这种情况下，弱引用对象可以存在较长的时间。
* 弱引用于软引用一样，在构造软引用是，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况
* 软引用、弱引用都非常适合来保存安歇可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。
* 在JDK1.2之后，提供了java.lang.ref.WeakReference类来实现弱引用：弱引用对象与软引用对象的最大不同在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是强行回收。弱引用对象更容易被GC回收

​	![截屏 2023-11-25 19.51.22.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311251953426.png)

### 6.4 虚引用-对象回收跟踪

* 也称为”幽灵引用“或者”幻影引用“，是所有引用类型中最弱的一个

* 一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾收集器回收

* 它不能单独使用，也无法通过虚引用来获取被引用对象。当试图通过虚引用的get()方法取得对象时，总是null

* 为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知

* 虚引用必须和引用对垒一起使用。虚引用在创建时，必须提供一个引用队列作为参数。当垃圾收集器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况

* 由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录

* 在JDK1.2之后提供了PhantomReference类来实现虚引用

  ![截屏 2023-11-25 20.02.01.jpeg](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311252003181.png)

```java
package com.smc.java;

import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;

/**
 * @Date 2023/11/25
 * @Author smc
 * @Description:
 */
public class PhantomReferenceTest {
    public static PhantomReferenceTest obj;//当前类对象声明
    static ReferenceQueue<PhantomReferenceTest> phantomQueue=null;//引用实例

    public static class CheckRefQueue extends Thread{
        @Override
        public void run() {
            while (true){
                if (phantomQueue !=null){
                    PhantomReference<PhantomReferenceTest> objt=null;
                    try {
                        objt= (PhantomReference<PhantomReferenceTest>) phantomQueue.remove();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (objt!=null){
                        System.out.println("追踪垃圾回收过程：PhantomReferenceTest实例被GC了");
                    }
                }
            }
        }
    }
    //finalize方法只能被调用一次
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("调用当前类的finalize()方法");
        obj=this;
    }

    public static void main(String[] args) {
        Thread t=new CheckRefQueue();
        //设置守护线程:当程序中没有非守护线程时，守护线程也就执行结束了
        t.setDaemon(true);
        t.start();
        phantomQueue=new ReferenceQueue<>();
        obj=new PhantomReferenceTest();
        //构造PhantomReferenceTest对象的虚引用，并制定了引用队列
        PhantomReference<PhantomReferenceTest> phantomRef = new PhantomReference<>(obj, phantomQueue);
        try {
            //不可获取虚引用中的对象
            System.out.println(phantomRef.get());

            //将强引用去除
            obj=null;
            //第一次进行GC，由于对象可复活，GC无法回收该对象
            System.gc();
            Thread.sleep(1000);
            if (obj==null){
                System.out.println("obj is null");
            }else {
                System.out.println("obj 可用");
            }
            //将强引用去除
            obj=null;
            //第一次进行GC，由于对象可复活，GC无法回收该对象
            System.gc();
            Thread.sleep(1000);
            if (obj==null){
                System.out.println("obj is null");
            }else {
                System.out.println("obj 可用");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```



### 6.5 终结器引用（FinalReference）

* 它用以实现对象的finalize()方法，也可以成为终结器引用
* 无需手动编码，其内部配合引用队列使用。
* 在GC时，终结器引用入队，由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用。

# 十三、垃圾回收器

## 1、GC分类与性能指标

### 1.1 垃圾回收器概述

* 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现
* 由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本
* 从不同角度分析垃圾收集器，可以将GC分为不同的类型
* Java不同版本的新特性
  * 语法层面：Lambda表达式、switch、自动装箱、自动拆箱、enum
  * API层面：Stream API、新的日期时间、Optional、String、集合框架
  * 底层优化：JVM的优化，GC的变化、元空间、静态域、字符串常量池

### 1.2 垃圾回收器分类

* 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器
  * 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束
    * 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以串行回收默认被应用在客户端的Client模式下的JVM中
    * 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器
  * 在串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-world”机制
* 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器
  * 并发垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间
  * 独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束

* 按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器
  * 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片
  * 非压缩式的垃圾回收器不进行这操作
* 按工作内存的内存区间分，又可以分为年轻代垃圾回收器和老年代垃圾回收器

### 1.3 评估GC的性能指标

* **吞吐量：运行用户代码的时间占总运行时间的比例**
  * 总运行时间：程序 的运行时间+内存回收的时间
* 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例
* **暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间**
* 收集频率：相对于应用程序的执行，收集操作发生的频率
* **内存占用：Java堆区所占的内存大小**
* 快速：一个对象从诞生到被回收所经历的时间
* 这个三者共同构成一个“不可能 三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项
* 这三项里，暂停时间的重要性日益凸显。因为随着硬件的发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果
* 简单来说
  * 吞吐量
  * 暂停时间

#### 1.3.1 吞吐量

* 吞吐量就是CPU用于运行代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
* 这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应式不必考虑的
* 吞吐量优先，意味着在单位时间内，STWed时间最短：0.2+0.2=0.4

#### 1.3.2 暂停时间

* “暂停时间”是指一个时间段内应用程序暂停，让GC线程执行的状态
* 暂停时间优先，意味着尽可能让单次STW的时间最短

#### 1.3.3 吞吐量vs暂停时间

* 高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快
* 低暂停时间（低延迟）较好因为从最终用户的角度看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户的体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序
* 不幸的是“高吞吐量”和“低暂停时间”是一对相互竞争的目标（矛盾）。
  * 因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收
  * 相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降
* 在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中
* 现在标准：在最大吞吐量优先的情况下，降低停顿时间

## 2、不同的垃圾回收器概述

* 垃圾收集机制时Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。那么，Java常见的垃圾收集器有哪些？

### 2.1 垃圾收集器的发展史

![image-20231130225255700](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311302252921.png)

### 2.2 七种经典垃圾收集器

* 串行回收器：Serial、Serial Old
* 并行收集器：ParNew、Parallel Scavenge、Parallel Old
* 并发回收器：CMS、G1

![image-20231130225556336](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311302255649.png)

### 2.3 七款收集器于垃圾分代之间的关系

![image-20231130225646857](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311302256951.png)

* 组合关系

  ![image-20231130225727112](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202311302257227.png)

### 2.4 如何查看默认的垃圾回收器

* `-XX:+PrintCommandLineFlags`：查看命令行相关参数（包含使用的垃圾收集器）
* 使用命令行指令：` jinfo -flag`相关垃圾回收器参数 进程ID



## 3、Serial回收器：串行回收

* Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择
* Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器
* Serial收集器采用复制算法、串行回收和“Stop the World”机制的方式执行内存回收
* 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和“Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法
  * Serial Old是运行在Client模式下默认的老年代的垃圾回收器
  * Serial Old在Server模式下主要有两个用途：
    * 与新生代的Parallel Scavenge配合使用
    * 作为老年代CMS收集器的后备垃圾收集方案

* 优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有现成交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率
  * 运行在Client模式下的虚拟机是个不错的选择
* 在用户的桌面应用场景中，可用内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的
* 在HotSpot虚拟机中，使用` -XX:+UseSerialGC` 参数可以指定年轻代和老年代都使用串行收集器
  * 等价于新生代用Serial GC，且老年代用Serial Old GC

## 4、ParNew回收器：并行回收

* 如果说Serial GC年轻代中的 单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本
  * Par是Parallel的缩写，New：只能处理的是新生代
* ParNew收集器出了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、“Stop-the-World”机制
* ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器
* 对于新生代，回收次数频繁，使用并行方式高效
* 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）
* 由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial更高效？
  * ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量
  * 但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销
* 因为出了Serial外，目前只有ParNew GC能与CMS收集器配合工作
* 在程序中，开发人员可以通过选线` -XX:+UseParNewGC`手动指定使用ParNew收集器之心个内存回收任务。它表示年轻代使用并行收集器，不影响老年代
* ` -XX:ParallelGCThreads`限制线程数量，默认开启和CPU数据相同的线程数

## 5、Parallel Scavenge回收器：吞吐量优先

* HotSpot的年轻代中出了拥有ParNew收集器是基于并行回收以外，Parallel Scavenge手机器同样也采用了复制算法、并行回收和“Stop the World”机制
* 那么Parallel收集器的出现是否多次一举？
  * 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，它也被称为吞吐量优先的垃圾收集器
  * 自适应调节策略也是Parallel Scavenge 与ParNew一个重要区别
* 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序
* Parallel收集器在JDK1.7时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器
* Parallel Old收集器采用了标记-压缩算法，但同样也是机遇并行回收和“Stop the World”机制
* 在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错
* 在Java8中，默认是此垃圾收集器

### 5.1 参数配置

* ` -XX:+UseParallelGC`：手动指定年轻代使用Parallel并行收集器执行内存回收任务
* ` -XX:UseParallelOlddGC`：手动指定老年代都是使用并行回收收集器。
  * 分别使用适用于新生代和老年代。默认jdk8是开启的
  * 上面两个参数，默认开启一个，另一个也会被开启（互相激活）
* ` -XX:ParallelGCThreads`：设置年轻代并行收集器的线程数，一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。 
  * 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量
  * 当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_COUNT]/8
* ` -XX:MaxGCPauseMillis`：设置垃圾收集器最大停顿时间（即STW的时间）。单位毫秒
  * 为了尽可能把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数
  * 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体吞吐量。所以服务器端适合Parallel，进行控制。
  * 该参数使用需谨慎
* ` -XX:GCTimeRatio` ：垃圾收集器时间占总事件的比例(=1/(N+1))。用于衡量吞吐量的大小
  * 取值范围（0,100）。默认值99，也就是垃圾回收时间不超过1%。
  * 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例
* ` -XX:+UseAdaptiveSizePolicy`：设置Parallel Scavenge收集器具有自适应调节策略
  * 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老念叨的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点
  * 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作

## 6、CMS回收器：低延迟

* 在JDK1.5时期，HotSpot退出了一款在强交互应用中巨虎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现让垃圾收集线程与用户线程同时工作
* CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合和与用户交互的程序，良好的相应速度能提升用户体验。
  * 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求
* CMS的垃圾收集算法采用标记-清除算法，并且也会STW
* 不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个
* 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有许多系统使用CMS GC

### 6.1 CMS的工作原理

![image-20231203152956753](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312031529504.png)

* CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段
  * 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为STW机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快
  * 并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
  * 重新标记（Remark）标记：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通产公会币初始标记阶段稍长一些，单页远比并发标记阶段的时间段
  * 并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

* 由于最耗费时间的并发标记与并发清除阶段都不需要暂停龚总，所以整体的回收是低停顿的
* 另外，由于在垃圾收集阶段用户线程没有中断，所以子啊CMS回收过程中，还应该确保应用程序用户有足够的内存可用。因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了在进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这是迅疾件刚启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾回收，这样停顿时间就很长了
* 为什么不把Mark Sweep算法（会造成内存碎片）改为Mark Compact呢？
  * 因为当并发清除的时候，用Compact整理内存的话，远啦的用户线程的使用内存会出现变化，无法保证用户线程的执行。Mark Compact更适合STW的场合使用
* CMS的有点
  * 并发收集
  * 低延迟
* CMS的弊端
  * 会产生内存碎片：导致并发清除后，用户线程可用的空间不足，无法分配大对象的情况下，不得不提前出发Full GC
  * CMS收集器对CPU的资源资源非常敏感：在并发阶段，它虽然不会导致用户停顿，但是因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低
  * CMS收集器无法处理浮动垃圾：可能出现“Current Mode Failure”失败而导致另一次Gull GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程时同时运行或者交叉运行的，那么在并发阶段如果产生新的垃圾对象，CMS无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对线更没有被即时回收，从而只能在下一次执行GC时释放这些之前并未被回收的内存空间

### 6.2 CMS可以设置的参数

* ` -XX:+UseConcMarkSweepGC` ：手动指定使用CMS收集器之心个内存回收任务
  * 开启该参数后会自动将-XX:UseParNewGC打开。即：ParNew（Young区用）+CMS（Old区用）+Serial Old的组合
* ` -XX:CMSInitiatingOccupanyFraction`：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收
  * JDK5及以前版本的默认值为68，即当老年代的空间使用达到68%时，会进行一次CMS回收。JDK6及以上版本默认值为92%
  * 如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显的改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数
* ` -XX:+UseCMSCompactAtFullCollection`：用于执行在执行完Full GC后对内存空间进行压缩整理，一次避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了
* ` -XX:CMSFullGCsBeforeCompaction`：设置在执行多少次Full GC后对内存空间进行压缩整理。
* ` -XX:ParallelCMSThreads`：设置CMS的线程数量
  * CMS默认启动的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，收到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕 
* JDK9将CMS标记为Deprecate过时，JDK14删除CMS垃圾回收器

## 7、G1回收器：区域化分代式

* 既然有了前面几个强大的GC，为什么还要发布Garbage Firest（G1）GC？
  * 原因在与应用程序所应对的业务越来越庞大、复杂、用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断尝试对GC进行优化、G1（Garbage-First）垃圾收集器是自爱Java7 Update4之后引入的一个新的垃圾收集器，是宕机收集器技术发展的最前沿成果之一
  * 于此同事，为了适应现在不断扩大的内存和不断增加的处理器熟练个，进一步降低暂停（pause time），同时兼顾良好的吞吐量
  * 官方给G1设定的目标是在延迟可控情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重担与期望
* 为什么名字叫做Garbage First（G1）呢？
  * 因为G1是一个并行回收器，它把堆内存分割为很多不想关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代
  * G1 GC有计划地避免整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的手机时间，优先回收价值最大的Region
  * 由于这中方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）
* G1(Garbage-First)是一款面向服务端应用的垃圾收集器，主要针对配备多喝CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特性
* 在JDK1.7版本正式启用，溢出了Experimental标识，是JDK9以后得默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为“全能收集器”
* 于此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用`-XX:UseG1GC`来启用

### 7.1 G1回收器的特点（优势）

* 与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示

#### 7.1.1并行与并发

* 并行性：G1在回收区间，可以有多个GC线程同时工作，有效利用多喝计算能力。此时用户线程STW
* 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会再整个回收阶段发生完全阻塞应用程序的情况

#### 7.1.2 分代收集

* 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，他不要求整个Eden区、年轻代区或者老年代区是连续的，也不再坚持固定大小和固定数量
* 从堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代
* 和之前的各类回收器不同，它同时基建股年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代

#### 7.1.3 空间整合

* CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理
* G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看做是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前出发下一次GC。尤其是Java堆非常大的时候，G1的优势更加明显

#### 7.1.4 可预测的停顿时间模型（即：软实时soft -real-time）

* 这是G1相对于CMS的另一大优势，G1除了追求地停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，小号在垃圾收集器上的时间不超过N毫秒
  * 由于分区的原因，G1可以只回收部分区域的垃圾，这样缩小了回收的范围，因此对于STW的发生也能有较好的控制
  * G1跟踪各个Region里垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要时间的经验值），在后台维护一个优先列表，每次根据允许的手机时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率
  * 相比于CMS GC，G1未必能做大CMS在最好的情况下的延时停顿，但是最差情况要好很多

### 7.2 G1回收器的缺点

* 相对与CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高
* 从经验上来说，在小内存应用上CMS的表现大概率会由于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间

### 7.3 G1回收器的参数设置

* `-XX:+UseG1GC`：手动指定使用G1收集器执行内存回收任务
* `-XX:G1HeapRegionSize`：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出2048个区域。默认是堆内存的1/2000
* `-XX:MaxGCPauseMilllis`：设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms
* `-XX:ParallelGCThread`：设置STW工作线程数的值。最大设置为8
* `-XX:ConcGCThread`：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThread）的1/4左右
* `-XX:InitiatingHeapPccupancyPercent`：设置出发并发GC周期的Java堆占用率阈值。超过此值，就触发GC.默认值是45

### 7.4 G1回收器的常见操作步骤

![image-20231203170330533](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312031703916.png)

### 7.5 G1回收器的使用场景

* 面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）
* 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案
* 如：在堆大小约6GB或更大时，可预测的暂停时间可以抵御0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会更长）
* 用来替换JDK1.5中的CMS收集器；在下面的情况下，G1比CMS更合适
  * 超过50%的Java堆被活动数据占用
  * 对象分配频率或年代提升频率变化很大
  * GC停顿时间过长（长于0.5至1秒）
* HotSpot垃圾收集器里，处理G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程

### 7.6 分区Region：化整为零

* 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定个，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过`-XX:G1HeapRegionSize`设定。所有的Region大小相同，且在JVM生命周期内不会被改变
* 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，他们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续

![image-20231204232258314](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312042322785.png)

* 一个Region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，S表示Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间
* G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，将放到H
* 对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待

### 7.7 G1回收器垃圾回收过程

* G1 GC的垃圾回收过程主要包括如下三个环节

  * 年轻代GC（Young GC）
  * 老年代并发标记过程（Concurrent Marking）
  * 混合回收（Mixed GC）
  * 如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护极致化，即强力回收

  ![image-20231204233901629](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312042339817.png)

* 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程：G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有的应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及

* 当堆内存使用到达一定值（默认45%）时，开始老年代并发标记过程

* 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对线管道空闲区间，浙西额空闲区间也就成为了老年代的一部分，和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时这个老年代Region是和年轻代一起被回收的

### 7.8 G1回收器垃圾回收过程：Remembered Set

* 一个对象被不同区域引用的问题
* 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确
* 在其他的分代收集器，也存在这样的问题（而G1更突出）
* 回收新生代也不不同时扫描老年代？
* 这样的话会降低Minor GC的效率
* 解决办法
  * 无论G1还是其他分代收集器，JVM都是使用Remembered Set 来避免全局扫描
  * 每个Region都有一个对应的Remembered Set
  * 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作
  * 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）
  * 如果不同，通过CardTable把相关引用信息记录到引用指向对象所在Region对应的Remembered Set中
  * 当进行垃圾收集时，在GC根结点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏

### 7.9 G1回收过程一：年轻代GC

* JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程
* 年轻代垃圾回收只会回收Eden区和Survivor区
* YGC时，首先G1执行STW，G1创建回收集（Collection Set），回收集时值需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有内存分段

![image-20231204235607382](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312042356777.png)

![image-20231205001620026](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312050016165.png)

* 对于应用程的引用赋值语句Objet.filed=object,JVM会在之前和之后执行特殊的操作一在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对dirty Card Queue中所有的card进行处理，已更新RSet，保证RSet实时准确的反映引用关系
* 那为什么不在引用赋值语句出直接更新Rset呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多

### 7.10 G1回收可选过程二：并发标记过程

![image-20231205001912251](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312050019369.png)

### 7.11 G1回收可选过程三：混合回收

![image-20231205002046854](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312050020937.png)

![image-20231205002233252](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312050022541.png)

### 7.12 G1回收可选过程四：Full GC

![image-20231205002418213](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312050024316.png)

### 7.13 G1回收过程：补充

* 从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region，停顿时间是用户可控制的，所以并不迫切区实现，而选择把这个特性放到G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择完全暂停用户线程的实现方案

### 7.14 G1回收器优化建议

* 年轻代大小
  * 避免使用-Xmn或-XX:NewRation等相关选项显式设置年轻代大小
  * 固定年轻代的大小会覆盖暂停时间目标
* 暂停时间目标不要太过严苛
  * G1 GC的吞吐量目标是90%的应用程序和10%的垃圾回收时间
  * 评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量

## 8、垃圾回收器总结

* 截止JDK1.8，一共7款不同给的垃圾收集器

  ![image-20231205003329413](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312050033731.png)

* Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升
* 怎么选择垃圾收集器？
  * 优先调整堆的大小让JVM自适应完成
  * 如果内存小于100M，使用串行收集器
  * 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器
  * 如果是多CPU、需要高吞吐量、允许停顿时间超过1s，选择并行或者JVM自己选择
  * 如果是多CPU、追求低停顿时间，需要快速响应（比如延迟不能超过1s，如互联网应用），使用并发收集器
  * 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1

## 9、GC日志分析

* 通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略

* 内存分配与垃圾回收的参数列表

  * `-XX:+PrintGC`：输出GC日志。类似：-verbose:gc

    ![image-20231205225728924](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312052257146.png)

  * `-XX:+PrintGCDetails`:输出GC详细日志

    ![image-20231205225908265](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312052259421.png)

  * `-XX:+PrintGCTimeStamps`:输出GC时间戳（以基准时间的形式）

  * `-XX:+PrintGCDateStamps`:输出GC的时间戳（以日期的形式，如2013-05-04T21:53:59.234_0800）

    ![image-20231205230116394](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312052301538.png)

  * `-XX:+PrintHeapAtGC`:在进行GC的前后打印出堆的信息

  * `-Xloggc:../logs/gc.log`:日志文件的输出路径

![image-20231205230243285](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312052302391.png)

![image-20231205230357133](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312052303441.png)

### 9.1 GC日志工具

* 常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等

## 10、垃圾回收器的新发展

![image-20231206003733262](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060037724.png)

### 10.1 JDK11 新特性

![image-20231206003832680](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060038002.png)

### 10.2 Open JDK12 的Shenandoah GC

![image-20231206003934289](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060039770.png)

![image-20231206004118591](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060041055.png)

![image-20231206004249067](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060042394.png)

![image-20231206004348531](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060043989.png)

### 10.3 革命性的ZGC

![image-20231206004608088](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060046438.png)

![image-20231206004728540](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060047860.png)

![image-20231206004746738](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060047056.png)

![image-20231206004849761](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060048418.png)

![image-20231206004957042](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202312060049525.png)
