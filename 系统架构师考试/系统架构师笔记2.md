# 四、项目管理

## 1、盈亏平衡分析(❤)

* 正常情况下：销售额=固定成本+可变成本+税费+利润
* 盈亏平衡时：销售额=固定成本+可变成本+税费 

![image-20230910004720595](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309100047681.png)

![image-20230910005206109](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309100052187.png)

## 2、进度管理(❤❤❤)

![image-20230910005424521](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309100054785.png)

### 2.1 WBS

![image-20230910005537475](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309100055558.png)

* WBS分解的基本要求
  * WBS的工作包是可控和可管理的，不能过于复杂
  * 任务分解也不能过细，一般原则WBS的树型结构不超过6层
  * 每个工作包要有一个交付成果
  * 每个任务必须有明确定义的完成标准
  * WBS必须有利于责任分配

### 2.2 关键路径法

![image-20230910011711268](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309100117341.png)

* 关键路径法实在制定进度计划时使用的一种进度网络分析技术。关键路径法沿着项目进度网络路线进行正向与反向分析，从而计算出所有计划活动该理论上的最早开始和完成日期、最迟开始和完成日期，不考虑任何资源限制
* 总时差【即：松弛时间】：在不延误总工期的前提下，该活动的机动时间。活动的总时差等于该活动最迟完成时间与最早完成时间之差，或该活动最迟开始时间与最早开始时间之差
* 对于网路计划中以重点为完成节点的活动，其自由时差与总时差相等。此外，由于活动的自由时差是其总时差的构成部分，所以当活动的总时差为零时，其自由时差必然为零，可不必进行专门计算

### 2.3 甘特图（Gantt）

![image-20230910011909263](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309100119345.png)

* 优点：甘特图制罐、简单、容易制作，便于理解，能够清晰地表示出每一项任务的起始时间与结束时间，一般使用比较简单的小型项目，可用于WBS的任何层次、进度控制、资源优化、编制资源和费用计划
* 缺点：不能系统地表达一个项目所包含的各项工作之间的复杂关系，难以进行定量的计算和分析，以及计划的优化等 

## 3、软件质量管理(❤❤)

* 影响软件质量的3组因素

![image-20230910013510161](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309100135223.png)

### 3.1 软件质量控制与质量保证

*  质量保证【QA】一般是每隔一段时间（例如，每个阶段末）进行的，主要通过系统的质量设计和过程分析来保证项目的质量。独特工具包括：质量设计和过程分析
* 质量控制【QC】是实时监控项目的具体结果，以判断它们是否符合相关质量标准，指定有效方案，以消除产生质量问题的原因
* 质量保证的主要目标
  * 【事前预防】工作
  * 尽量在刚刚引入缺陷时将其捕获，而不是让缺陷扩散到下一个阶段
  * 作用于【过程】而【不是最终产品】
  * 贯穿于【所有的活动之中】，而不是只集中于一点

### 3.2 软件能力成熟度模型集成【CMMI】

![image-20230910014206046](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309100142112.png)

## 4、软件配置管理(❤❤)

* 产品配置是指一个产品再起生命周期各个阶段所产生的各种形式（机器可读或人工可读）和各种版本的文档、计算机程序、部件及数据的集合
* 关于配置项
  * 基线配置项（可交付成果）：需求文档、设计文档、源代码、可执行代码测试用例、运行软件所需数据等
  * 非基线配置项：各类计划（如项目管理计划，进度管理计划）、各类报告
* 软件配置管理核心内容包括【版本控制】和【变更控制】

### 4.1 版本控制

![image-20230910014827486](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309100148568.png)

* 出于草稿状态的配置项的版本号格式为：0.YZ，其中YZ数字范围为01~99.随着草稿的不断完善，YZ的取值应递增。YZ的初值和增幅由开发者自己把握
* 出于正式发布状态的配置项的版本号格式为：X.Y。其中X位主版本号，取值范围为1\~9；Y为次版本号，取值范围为1\~9。配置项第一次正式发布时，版本号为1.0
* 如果配置项的版本升级幅度比较小，一般只增大Y值，X值保持不变。。只有当配置项版本升级幅度比较大时，才允许增大X值
* 出于正在修改状态的配置项的版本号为：X.YZ。在修改配置项时，一般只增大Z值，X.Y值保持不变

## 5、软件工具

* 按软件过程活动将工具分为
  * 软件开发工具：需求分析工具、设计工具、编码与排错工具、测试工具
  * 软件维护工具：版本控制工具（VSS,CVS,SCCS,SVN）、文档分析工具、开发信息库工具、逆向工程工具、再工程工具
  * 软件管理和软件支持工具：项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择

# 五、案例特训专题【技巧篇】

## 1、考纲分析

![image-20230910163806058](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101638151.png)

## 2、历年试题分析

![image-20230910163957793](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101639898.png)![image-20230910164018386](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101640474.png)![image-20230910164033402](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101640507.png)![image-20230910164045031](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101640210.png)

## 3、如何解答试题

### 3.1 试题对考生的要求

* 具有一定的系统架构设计实践经验，有较好的分析问题和解决问题的能力
* 对于有关系统架构设计方面，有广博而坚实的知识或见解
* 对应用的背景、事实和英国关系等有较强的理解能力和归纳能力
* 对于一些可以简单定量分析的问题已有类似的经验并能进行估算，对于只能定性分析的问题能用简练的语言抓住要点加以表达
* 善于从一段书面叙述中取出最必要的信息，有时还需要舍弃一些无用的叙述或似是而非的内容

### 3.2 试题解答步骤

* 标出问题要点，以此作为主要线索进行分析和思考
* 对照问题要点仔细阅读正文
* 通过定性分析或者定量估算，构思答案的要点
* 以最简练的语言写出答案

### 3.3 试题解答注意事项

* 遇到新的知识点，不要慌，稳住心态
* 列条目回答问题，把自己认为对的都写上
* 分析题目问题的倾向性，顺势答题

# 六、案例特训专题【软件工程篇】

## 1、需求分析(❤❤❤❤)

### 1.1 结构化需求分析【SA】

![image-20230910165505861](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101655949.png)

### 1.2 数据流图基本概念

| 元素           | 说明                                                         | 图元                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据流         | 由一组固定成分的数据组成，表示数据的流向。每个数据流通常有一个合适的名词，反映数据流的含义 | ![image-20230910165649114](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101656193.png) |
| 加工           | 加工描述了输入数据流到输出数据流之间的变换，也就是输入数据流做了什么处理后编程了输出数据流 | ![image-20230910165807076](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101658142.png) |
| 数据存储(文件) | 用来表示暂时存储的数据，每个文件都有名字。流向文件的数据流表示写文件，流出的表示读文件 | ![image-20230910165919169](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101659244.png) |
| 外部实体       | 指存在于软件系统外的人员或组织                               | ![image-20230910170050248](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101700320.png) |

![image-20230910165947644](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101700450.png)

![image-20230910170154084](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101701220.png)

### 1.3 数据流图平衡原则

* 父图与子图之间的平衡

* 子图内平衡

* 异常现象

  ![image-20230910171543960](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101715060.png)

  * 黑洞：一个加工只有输入数据流而无输出数据流
  * 奇迹：一个加工只有输出数据流而无输入数据流
  * 灰洞：若一个加工的输入数据流无法通过加工产生输出流

### 1.4 答题技巧1

![image-20230910171841094](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101718176.png)

### 1.5 答题技巧2

* 补充实体
  * 人物角色：如客户、管理员、主管、经理、老师、学生
  * 组织机构：如银行、供应商、募捐机构
  * 外部系统：如银行系统、工资系统、后台数据库（当要开发的是中间件时）
* 补充存储
  * 存储的文件方面特征：“\*\*文件”，“\*\*表”，“\*\*库”，“\*\*清单”，“\*\*档案”
* 补充数据流
  * 数据平衡原则
    * 顶层图与0层图对比，是否顶层图有，但0层图无得数据流，或反之
    * 检查途中每个加工，是否存在只有入没有出，或只有出没有入，或根据输入的数据无法产生对应的输出的情况
  * 按题目说明与图进行匹配
    * 说明中的每一句话，都能与图中有对应关系，当把说明中的实体与数据流标识出来之后，容易缩小对应范围，找出纰漏
* 补充加工名
  * 加工时用于处理数据流的，所以要补充加工名，可以把该加工涉及到的数据流，在说明中标识出来，再在数据流名称的句子中，找“动词+名词”的结构，分析是否可作为加工
  * “动词+名词“如：生成报告、发出通知、批改作为、记录分数，当然这只是普遍情况，也有例外，如物流跟踪、用户管理

## 2、面向对象设计(❤❤)

![image-20230910173425981](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101734100.png)

### 2.1 用例图

![image-20230910173545682](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101735826.png)

* 用例图描述一组用例、参与者及它们之间的关系

* 用户角度描述系统功能
* 参与者是外部触发因素（包括用户、组织、外部系统、时间）
* 用例是功能单元

#### 1）细化用例描述

![image-20230910174141376](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101741491.png)

#### 2）包含、扩展、泛化

* 包含关系：其中这个提取出来的公共用例称为抽象用例，而把原始用例称为基本用例或基础用例。当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。【必然的】

  ![image-20230910174415941](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101744018.png)![image-20230910174937347](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101749423.png)

* 扩展关系：如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰。【可选的】

  ![image-20230910174638302](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101746381.png)![image-20230910174950295](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101749391.png)

* 当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象称为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系

  ![](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101750647.png)

  ![image-20230910175007086](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101750177.png)

### 2.2 类图与对象图

![image-20230910180102521](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101801625.png)

* 类图（class diagram）：类图描述一组类、接口、协作和它们之间的关系
* 对象图（object diagram）：对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照
* 类名，方法名，属性名
* 多重度
  * 1：表示一个集合中的一个对象对应另一个集合中的一个对象
  * 0..\*：表示一个集合中的一个对象对应另一个对象中的0个或多个对象（可以不对应）
  * 1..\*：表示一个集合中的一个对象对应另一个对象中的一个或多个对象（至少对应一个）
  * \*：表示一个集合中的一个对象对应另一个集合中的多个的对象
* 关系

#### 1）关系

* 依赖关系：一个事物发生变化影响另一个事物

  ![image-20230910180542048](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101805131.png)

* 泛化关系：特殊/一般关系

  ![image-20230910180612494](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101806629.png)

* 关联关系：描述了一组链，链是对象之间的链接

  ![image-20230910180746859](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101807930.png)

  * 聚合关系：整体与部分生命周期不同

    ![image-20230910180710113](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101807230.png)

  * 组合关系：整体与部分生命周期相同

    ![image-20230910180721611](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101807726.png)

* 实现关系：接口与类之间的关系

  ![image-20230910180816489](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309101808611.png)

  

### 2.3 顺序图

* 顺序图(sequence diagram，序列图)。顺序图是一种交互图，它强调对象之间消息发送的顺序，同时显示对象之间的交互

![image-20230910204522218](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102045385.png)

### 2.4 通信图（协作图）

* 通信图（communication diagram）。通信图是一种交互图，它强调对象之间存在的消息收发关系，而不专门突出这些消息发送的时间顺序

![image-20230910204639825](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102046985.png)

### 2.5 状态图

* 状态图（state diagram）是对类描述的补充。用于展示此类对象所具有的可能状态，以及某些时间发生时其状态转移情况。

![image-20230910204759338](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102047512.png)

![image-20230910205113244](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102051375.png)

### 2.6 活动图

* 活动图（activity diagram）是一种特殊的状态图。活动图描述一个操作中要进行的各项活动的执行流程。同时，也常被用来描述一个用例的处理流程或者某种交互流程
* 活动图将进程或其他计算结构展示为计算内部一步步的控制流和数据流。它强调对象间的控制流程

![image-20230910205426462](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102054592.png)

![image-20230910205551073](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102055206.png)

* 活动图与流程图的差异
  * 活动图描述的是对象活动的顺序关系所遵循的规则，它着重表现系统的行为，而非处理过程；而流程图着重描述处理过程。
  * 流程图一般都限于顺序进程，而活动图则可以支持并发进程
  * 活动图是面向对象的，而流程图是面向过程的

### 2.7 定时图

* 定时图也叫计时图，也是一种交互图，用于展示交互过程中的真实事件信息，具体描述对象状态变化的时间点以及维持特定状态的时间段。

  ![image-20230910210046786](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102100907.png)

### 2.8 构件图和包图

* 构件图（component diagram）。构件图描述一个封装的类和它的接口、端口，以及由内嵌的构件和连接件件构成的内部结构。构件图用于表示系统的静态设计实现视图。对于由小的部件构建大的系统来说，构件图是很重要的。构件图是类图的变体。

  ![image-20230910210543388](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102105547.png)

* 包图，包的图标像是一个带标签的文件夹，包的基本思想是把共同工作的元素放到一个文件夹中。例：多个类或构件组成了一个子系统，就可以将它们放到一个包中。

### 2.9 部署图

* 部署图（deployment diagram）。部署图描述对运行时处理节点及在其中生存的构件的配置。部署图给出了架构的静态部署视图，通常一个节点包含一个或多个部署图

  ![image-20230910210916449](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102109573.png)

# 七、软件架构设计

## 1、软件架构的概念（❤❤❤）

### 1.1 概念

* 架构的本质

  * 软件架构为软件系统提供了一个结构、行为和属性的高级抽象

  * 软件架构风格是特定应用领域的惯用模式，架构定义一个词汇表和一组约束

* 架构的作用

  * 软件架构师项目干系人进行交流的手段

  * 软件架构是可传递和可复用的模型，通过研究软件架构可能预测软件的质量

  * 软件架构是推理和控制的更改更加简单，有助于循序渐进的原型设计，可以作为培训的基础

* 软件架构=软件体系结构。架构设计就是需求分配，即将满足需求的职责分配到组件上。

  ![image-20230910220705197](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102207281.png)

### 1.2 架构的发展历程

![image-20230910220951406](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102209480.png)

### 1.3 架构的”4+1“视图

![image-20230910221130917](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102211994.png)

## 2、基于架构的软件开发（❤❤❤❤）

### 2.1 概念

* ABSD方法是架构驱动，即强调由业务、质量和功能需求的组合驱动架构设计
* ABSD方法有三个基础。第一个基础是功能的分解。在功能的分解中，ABSD方法使用工艺有的基于模块的内聚和耦合技术；第二个基础是通过选择架构风格来实现质量和业务需求；第三个基础是软件模版的使用
* 视角与视图：从不同的视角来检查，所以会有不同的视图
* 用例用来捕获功能需求、特定场景用来捕获质量需求

### 2.2 开发过程

![image-20230910222205373](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102222498.png)

![image-20230910222333819](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102223993.png)

![image-20230910222642318](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102226469.png)



## 3、软件架构风格（❤❤❤❤❤）

### 3.1 概念

* 架构风格定义了用于描述系统的术语表和一组指导构件系统的规则

  | 五大架构风格                           | 子风格                                                       |
  | -------------------------------------- | ------------------------------------------------------------ |
  | 数据流风格【Data Flow】                | 批处理【Batch Sequential】、管道-过滤器【Pipes and Filters】 |
  | 调用/返回风格【Call/Return】           | 主程序/子程序【Main Program and Subroutine】 面向对象【Object-oriented】、分层架构【Layered System】 |
  | 独立构建风格【Independent Components】 | 进程通信【Communicating Processes】事件驱动系统（隐式调用）【Event system】 |
  | 虚拟机风格【Virtual Machine】          | 解释器【interpreter】、规则系统【Rule-based System】         |
  | 以数据为中心【Data-centered】          | 数据库系统【Database System】、黑板系统【Blackboard System】、超文本系统【Hypertext System】 |

### 3.2 数据流风格

![image-20230910223607824](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102236285.png)

| 优点                                                         | 缺点                                                         | 典型实例                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------- |
| 1、松耦合【高内聚-低耦合】<br>2、良好的重用性/可维护性<br>3、可扩展性【标准接口适配】<br>4、良好的隐蔽性<br>5、支持并行 | 1、交互性较差<br>2、复杂性较高<br>3、性能较差（每个过滤器都需要解析与合成数据） | 传统编译器<br>网络报文处理 |

* 数据流风格

  * 批处理序列：大量整体数据、无需用户交互

  * 管道-过滤器：流式数据、若用户交互

    ![image-20230910224130428](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102241578.png)

### 3.3 调用/返回风格

![image-20230910224317095](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102243189.png)





* 调用/返回风格

  * 主程序/子程序：面向过程

  * 面向对象：对象的方法调用

  * 分层：层与层之间的方法调用

    ![image-20230910224450142](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102245121.png)

    | 优点                                                         | 缺点                                                         | 特点                                                         |
    | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 1、良好的重用性、只要接口不变可用在其他处<br>2、可维护性好<br>3、可扩展性好，支持递增设计 | 1、并不是每个系统都方便分层 <br/>2、很难找到一个合适的、正确的层次抽象方法<br>3、笔筒层次自己考阿妈匹配金额低嘎婆的系统很难实现 | 各个层次的组件形成不同功能级别的虚拟机<br>多层相互系统工作，而且实现透明 |

### 3.4 独立构件风格

![image-20230910225041353](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102250497.png)

| 优点                                           | 缺点                                                         | 特点                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1、松耦合<br>2、良好的重用性/可修改性/可扩展性 | 1、构件放弃了对系统计算的控制。一个构件触发一个事件时，不能确定其他构件是否会响应它。而且即使它知道时间注册了哪些构件的过程，它也不能保证这些过程被调用的顺序<br>2、数据交换的问题<br>3、既然过程的语义必须依赖于被触发时间的上下文约束，关于正确性的推理就存在问题 | 系统有若干字系统构成且成为一个整体；系统有统一的目标；子系统有主从之分；每一子系统有自己的事件收集和处理机制 |

![image-20230910225958590](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102259726.png)

### 3.4 虚拟机风格

![image-20230910230331570](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102303791.png)

| 子分类     | 优点                   | 缺点       | 特点                         | 适合领域                     |
| ---------- | ---------------------- | ---------- | ---------------------------- | ---------------------------- |
| 解释器     | 可以灵活应对自定义场景 | 复杂度较高 |                              | 适用于需要”自定义规则“的场合 |
| 规则为中心 | 可以灵活应对自定义场景 | 复杂度较高 | 在解释器的基础上增加经验规则 | 适用于专家系统               |

* 解释器体系结构风格

  ![image-20230910230810243](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102309210.png)

* 规则系统体系结构风格：规则集、规则解释器、规则/数据选择及工作内存，一般用在人工智能领域和DSS(决策支持系统)

  ![image-20230910230940687](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102309794.png)

### 3.5 仓库风格【以数据为中心】

![image-20230910231150565](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102311662.png)

![image-20230910231328181](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102313398.png)

| 子分类     | 优点                                               | 缺点                                                         | 特点                                                 | 典型实例                                        |
| ---------- | -------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------------------------- | ----------------------------------------------- |
| 数据库系统 |                                                    |                                                              | 以数据为中心                                         |                                                 |
| 黑板系统   | 可更改性和可维护性；可重用的知识源；容错性和健壮性 | 测试困难；不能保证有好的解决方案；难以建立好的控制策略；低效；开发困难；缺少并行机制 | 在以数据为中心的基础上，使用中心数据出发业务逻辑部件 | 语音识别<br/>模式识别<br/>图像处理<br/>知识推理 |

### 3.6 闭环控制架构【过程控制】

![image-20230910232219731](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102322873.png)

* 适合于嵌入式系统，用于解决简单闭环控制问题
* 经典应用：空调温控，定速巡航

### 3.7 C2风格（层次型架构风格）

![image-20230910232428844](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102324932.png)

* C2架构的基本规则
  * 构件和连接件都有一个顶部和一个底部
  * 构件的顶部要连接到连接件的底部，构件的底部要连接到连接件的顶部，构件之间不允许直连
  * 一个连接件可以和任意数目的其他构件和连接件连接
  * 当两个连接件进行直连连接时，必须由其中一个的底部到另一个的顶部

### 3.8 软件架构风格-ADL

* ADL是这样一种形式化语言，它在底层语义模型的支持下，为软件系统的概念模型结构提供了具体语法和概念框架
* ADL的三个基本元素
  * 构件：计算或数据存储单元
  * 连接件：用于构建之间交互建模的体系结构构造块及其支配这些交互的规则
  * 架构配置：描述体系结构的构件与连接件的连接图

### 3.9 架构风格判断

![image-20230910233025170](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102330355.png)

![image-20230910233040198](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102330388.png)

![image-20230910233325698](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102333786.png)

![image-20230910233350034](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102333210.png)

![image-20230910233416437](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102334652.png)

![image-20230910233446769](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102334992.png)

![image-20230910233601810](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102336038.png)

![image-20230910233656783](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102336962.png)

### 3.10 MDA风格

* MDA的3种核心模型

  * 平台独立模型（PIM）：具有高抽象层次、独立于任何实现技术的模型
  * 平台相关模型（PSM）：为某种特定实现技术量身定做，让你用这种技术中可用的视线构造来描述系统的模型。PIM会被变换成一个或多个PSM
  * 代码（Code）：用源代码对系统的描述（规约）。每个PSM都将变换成代码

  ![image-20230910234319706](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102343858.png)

## 4、特定领域软件架构【DSSA】（❤❤❤）

### 4.1 基本概念

* 定义：特定领域软件架构一一个特定问题领域为对象。形成由领域参考模型、参考需求、参考架构等组成的开发基础架构，支持一个特定领域中多个应用的生成。

![image-20230910234800286](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102348549.png)

### 4.2 参与人员

![image-20230910234841591](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102348758.png)

* 领域专家：有经验的用户、从事该领域中系统的需求分析、设计、实现以及项目管理的有经验的软件工程师等。领域专家的主要任务包括提供关于领域中系统的需求规约和实现的知识
* 领域分析人员：领域分析人员应由具有知识工程背景的有经验的系统股份系人员来担任
* 领域设计人员：领域设计人员应由有经验的软件设计人员来担任
* 领域实现人员：领域实现人员应由有经验的程序设计人员来担任

### 4.3 建立过程

![image-20230910235152393](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102351509.png)

### 4.4 三层次模型

![image-20230910235226925](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102352121.png)

## 5、软件质量属性（❤❤❤❤❤）

![image-20230910235515364](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309102355499.png)

### 5.1 性能

* 性能（performance）是指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数
* 例如
  * 同时支持1000并发
  * 响应时间小于1s
  * 显示分辨率达到4K

![image-20230911000035979](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309110000272.png)

### 5.2 可用性

* 可用性（availability）是系统能够正常运行的时间比例。经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示
* 例如
  * 主服务器故障，1分钟内切换至备用服务器
  * 系统故障，1小时内修复
  * 系统支持7X24小时工作

![image-20230911000353278](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309110003449.png)

### 5.3 安全性

* 安全性（security）是指系统在线个发用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。安全性又可划分为机密性【信息不泄露给未授权的用户】、完整性【防止信息被篡改】、不可否认性【不可抵赖】及可控性【对信息的传播及内容具有控制的能力】等特性
* 例如
  * 可抵御SQL注入攻击
  * 对计算机的操作都有完整记录
  * 用户信息数据库授权必须保证99.9%可用

![image-20230911001346452](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309110013610.png)

### 5.4 可修改性

* 可修改性（modifiability）是指能够快速地一较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量可修改性
* 例如：
  * 更改系统报表模块，必须在2人周内完成
  * 对Web界面风格进行修改，修改必须在4人月内完成

![image-20230911221204461](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112212677.png)

### 5.5 易用性

* 易用性关注的是对用户来说完成某个期望任务的容易程度和系统所提供的用户支持的种类
* 例如
  * 界面友好
  * 新用户学习使用系统时间不超过2小时

### 5.6 可测试性

* 软件可测试性是指通过测试解释软件缺陷的容易程度
* 例如
  * 提供远程调试接口，支持远程调试

## 6、软件架构评估（❤❤❤❤）

* 敏感点是一个或多个构件（和/或构件之间的关系）的特性。

* 权衡点是影响多个质量属性的特性，是多个质量属性的敏感点。

  ![image-20230911222330365](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112223496.png)

* 风险点是指架构设计中潜在的、存在问题的架构决策所带来的隐患。

* 非风险点是指不会带来隐患，一般以”XXX要求是可以实现（或接收）的“方式表达 。

![image-20230911223229145](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112232230.png)

|          | 性能 | 安全性 | 可用性 | 易用性 | 可测试性 | 可维护性 |
| :------: | :--: | :----: | :----: | :----: | :------: | :------: |
|   性能   |      |   -    |        |   -    |    -     |    -     |
|  安全性  |  -   |        |        |   -    |    -     |          |
|  可用性  |      |        |        |        |          |          |
|  易用性  |  -   |        |   -    |        |    -     |          |
| 可测试性 |  -   |        |        |        |          |    +     |
| 可维护性 |  -   |        |   +    |        |    +     |          |



### 6.1 机构评估方法

* 基于调差问卷（检查表）的方式
* 基于度量的方式
* 基于场景的方式

![image-20230911223750067](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112237228.png)

* 【场景】是从风险承担者的角度与系统交互的简短描述。场景可从六个方面进行描述：刺激源、刺激、制品、环境、响应、响应度量

  ![image-20230911224154569](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112241724.png)

  * 【软件架构分析法（SAAM）】：最初关注可修改性，后扩充到可移植性、可扩充性等
  * 【架构权衡分析法（ATAM）】：由SAAM发展而来，主要针对：性能、实用性、安全性、可修改性
  * 【成本效益分析法（CBAM）】：在ATAM基础上建立的，软件的”经济“模型

### 6.2 SAAM

* 最初用于分析架构可修改，后扩展到其他质量属性

![image-20230911224714189](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112247346.png)

### 6.3 ATAM

* 由SAAM发展而来，主要针对：性能、实用性、安全性、可修改性，在系统开发之前，对这些质量属性进行评价和折中

![image-20230911224835917](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112248125.png)

### 6.4 质量效用树

![image-20230911225053503](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112250654.png)

## 7、软件产品线（❤❤❤）

### 7.1 基本概念

![image-20230911225559625](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112255809.png)

### 7.2 双生命周期模型

![image-20230911225951764](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112259959.png)

### 7.3 建立方式

|              | 演化方式                                                     | 革命方式                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 基于现有产品 | 基于现有产品架构设计产品线的架构，经演化现有构件，开发产品线构件 | 核心资源的开发基于现有产品集的需求和可预测性、将来需求的超集 |
| 全新产品线   | 产品线核心资源随产品新成员的需求而演化                       | 开发满足所有与其产品线成员的需求的核心资源                   |

* 将现有产品演化为产品线
* 用软件产品线替代现有的产品集
* 全新软件产品线的演化
* 全新软件产品线的开发

### 7.4 组织结构

* 组织结构类型
  * 设立独立的核心资源小组
  * 不设立独立的核心资源小组
  * 动态的组织结构
* 要成功实施产品线，主要取决于以下因素
  * 对该领域具备长期和深厚的经验
  * 一个用于构建产品的好的核心资源库
  * 好的产品线架构
  * 好的管理（软件资源、人员组织、过程）支持

## 8、构件与中间件技术（❤❤❤）

### 8.1 软件复用

* 软件复用【重用】是多次不同的软件开发过程中重复使用相同或相似【软件元素】的过程

* 软件元素：需求分析文档、设计过程、设计文档、程序代码、测试用例、领域知识

* 复用的历史发展线路

  ![image-20230911230829815](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112308032.png)

* 复用的维度
  * 水平复用：不分行业领域，通用
  * 垂直复用：分行业领域，专用

### 8.2 构件的复用

* 检索与提取构件

  ![image-20230911231144686](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112311843.png)

* 理解与评价构件

  ![image-20230911231240668](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112312885.png)

* 修改构件

  ![image-20230911231323329](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112313589.png)

* 组装构件

  ![image-20230911231429928](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112314136.png)

### 8.3 概念

* 构件的定义

  * 定义1：软件构件是一种组装单元，它具有规范的接口规约和显式的语境依赖。软件构件可以被独立地不熟并由第三方任意地组装
  * 定义2：构件是某系统中有价值的、几乎独立地并可替换的一个部分，它在良好定义的体系结构与语境内满足某清晰的功能
  * 定义3：构件是一个独立发布的功能部分，可以通过其接口访问它的服务

  ![image-20230911231942468](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112319671.png)

* 构件系统架构特性
  * 构件系统体系结构由一组平台决策、一组构件框架和构件框架之间的互操作设计组成
  * 构件框架式一种专用的体系结构（通常围绕一些关键的机制），同时，也是一组固定地作用与构建层次机制的策略
  * 概念框架的互操作设计包括系统体系结构连接的所有框架间的互操作的规则。
  * 构件是一组通常需要同时部署的原子构件。构件和原子构件之间的区别在于，大多数原子构件永远都不会被单独部署，尽管他们可以被单独部署
  * 一个原子构件是一个模块和一组资源
  * 模块式一组类和可能的非面向对象的结构体，比如过程或者函数
  * 资源是一个类型化的项的固定集合
  * 资源这个概念可以包含代码资源，进而包含模块。问题在于除了编译器编译一个模块或包生成的资源外，还可能存在其他的资源。在”纯对象“的方法中，资源是外部化的不可改变的对象--不可改变是因为构件没有持久化的标志，而且复制不能被区分

* 中间件是一类构件

* 中间件是一类系统软件

  ![image-20230911232647047](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112326252.png)

* 简化结构、屏蔽差异、利于复用
* 采用中间件的优点
  * 面向需求：即设计师集中精力于业务逻辑本身
  * 业务的分隔和包容性。应用开发人员可以按照不同的业务进行功能的划分，体现为不同的接口或交互模式
  * 设计与实现隔离。构架对外发生作用或构件间的交互，都是通过接口进行的，构件使用者只需要知道构件的接口，而不必关系其内部实现，这是设计与实现分离的关键
  * 隔离复杂的系统资源。架构很重要的一个功能就是将系统资源与应用构件隔离，这是保证构件可复用甚至”即插即用“的基础，与中间件的意图也是一致的
  * 复合标准的交互模型。中间件则实现了架构的模型，实现了标准的协议
  * 软件复用。中间件提供了构件封装，交互规则，与环境的隔离等机制，这些都为软件复用提供了方便的解决方案。
  * 提供对应用构件的管理。基于中间件的软件可以方便地进行管理，因为构件总可以通过标识机制进行划分。

### 8.4 中间件的分类

| 中间件分类             | 特点                                               |
| ---------------------- | -------------------------------------------------- |
| 通信处理（消息）中间件 | 可靠、高效、实时跨平台通信，eLink，MQSeries        |
| 事务处理（交易）中间件 | 事务分发，负载均衡，Tuxedo                         |
| 数据存取管理中间件     | 为虚拟缓冲存取、格式转换、解压等带来方便           |
| Web服务器中间件        | 有负载均衡、缓存、安全性等问题                     |
| 安全中间件             | 如：加密，认证等                                   |
| 跨平台和架构的中间件   | 解决跨平台问题，如：CORBA                          |
| 专用平台中间件         | 为特定应用领域设计领域参考模式，建立相应架构       |
| 网络中间件             | 功能包括网管、接入、网络测试、虚拟社区和虚拟缓冲等 |

### 8.5 构件标准

![image-20230911234750736](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112347061.png)

#### 1）CORBA

![image-20230911235016308](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309112350482.png)

* 伺服对象（Servant）：CORBA对象的真正实现，负责完成客户端请求
* 对象适配器（Object Adapter）：用于屏蔽ORB内核的实现细节，为服务器对象的实现者提供抽象接口，以便他们使用ORB内部的某些功能
* 对象请求代理（Object Request Broker）：解释调用并负责查找实现该请求的对象，将参数传给找到的对象，并调用方法返回结果。客户方不需要 了解服务对象的位置、通信方式、实现、激活或存储机制

# 八、案例特训专题【架构设计】

## 1、软件架构风格(❤❤❤❤)

![image-20230912215932099](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122159234.png)

![image-20230912221440177](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122214276.png)

* 请用200字以内的文字解释什么是软件架构风格，并从集成开发环境与用户的交互方式、集成开发环境的扩展性、集成开发环境的数据管理三个方面说明为什么最终采用了李工的设计方案。
  * 软件架构风格是指描述特定软件系统组织方式的惯用模式。组织方式描述了系统的组成构件和这些构件的组织方式，惯用模式则反应众多系统共有的结构和语义
  * 从集成开发环境与用户的交互方式看，用户通常采用交互式的方式对脚本语言进行编辑、解释执行与调试。在这种情况下，采用以数据存储为中心的架构风格能够很好的支持交互式数据处理，而管道-过滤器架构风格则对用户的交互式数据处理支持有限
  * 从集成开发环境的扩展性来看，系统核心需求要求实现各种编辑、语法检查、解释执行等各种功能的灵活组织、配置与替换。在这种情况下，采用以数据存储为中心的架构风格，以数据格式解耦各种功能之间的依赖关系，并可以灵活定义功能之间的逻辑顺序。管道-过滤器架构风格同样以数据格式解耦数据处理过程之间的依赖关系，但其在数据处理逻辑关系的灵活定义方面较差
  * 从集成开发环境的数据管理来看，集成开发环境需要支持脚本语言、语法树（用于检查语法错误）、可视化模型、调试信息等多种数据类型，并需要支持数据格式的转换。以数据存储为中心的架构将数据存储在统一的中心存储器中，中心存储器能够表示多种数据格式，并能够为数据格式转换提供各种支持。管道-过滤器架构风格通常只能支持有限度的数据格式，并且在数据格式转换方面的灵活性较差
* 在对软件系统架构进行设计时，要对架构需求进行分析，针对特定需求选择最为合适的架构风格，因此实际的软件系统通常会混合多种软件架构风格。请求核心需求进行分析，说明为了满足需求(2)和(3)，分别应采用何种架构风格，并概要说明采用相应架构风格后的架构设计过程
  * 为了满足需求2，应采用解释器架构风格。具体来说，需要：①为可视化编程元素即其拖拽关系定义某种语言。并描述其语法与含义。②编写解释器对该语言进行解释。③生成对应的脚本语言程序
  * 为了满足需求3，应该采用隐式调用架构风格。具体来说，首先需要定义”断点在调试过程中命中“这一事件，并实现当断点命中后的屏幕定位函数。集成开发环境维护一个事件注册表结构，将该事件与屏幕定位函数关联起来形成注册表中的一个记录项。在调试过程中，集成开发环境负责监听各种事件，当”断点在调试过程中命中“这一事件发生时，集成开发环境查找事件注册表，找到并调用屏幕定位函数，从而实现脚本语言编辑界面与调试代码的自动定位。

## 2、层次型软件架构风格(❤❤❤❤)

### 2.1 C/S架构与B/S架构 

![image-20230912222852433](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122229756.png)

### 2.2 常用层次式架构

* 层次架构是最通用的架构，常作为初始架构【关注分离】每层只负责本层的工作

![image-20230912223256469](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122232592.png)

### 2.3 MVC架构风格

* Model【模型层】：应用程序的主体部分。模型表示业务数据和业务逻辑。一个模型通常为多个视图提供数据。提高应用的可重用性
* View【视图】：用户看到并与之交互的界面。接收用户输入数据，项用户展示数据
* Controller【控制器】：用户界面与Model的接口。解释视图的输入，将其解释为系统能够理解的对象，同时识别用户运作，将其解释为对模型特定方法的调用。处理来自于模型的事件和模型逻辑执行的结果，调用适当的视图为用户提供反馈。

![image-20230912224046283](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122240453.png)

### 2.4 MVP架构风格

* MVP是MVC的变种，其优点包括
  * 模型与视图完全分离，可以修改视图而不影响模型
  * 可以更高效地使用模型，因为所有交互都发生在一个地方【Presenter】内部
  * 可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑
  * 如果把逻辑放在Presenter中，就可以脱离用户接口来测试这些逻辑【单元测试】

![image-20230912224352821](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122243007.png)

### 2.5 MVVM架构风格

![image-20230912224534317](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122245393.png)

### 2.6 RIA架构风格

![image-20230912225036164](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122250347.png)

### 2.7 数据访问层的设计

* ORM【Object Relational Mapping】：对象与关系数据之间的映射

* 映射关系表

  |        面向对象         |       关系数据库       |
  | :---------------------: | :--------------------: |
  |       类（class）       |  数据库的表（table）   |
  |     对象（object）      | 记录（record，行数据） |
  | 对象的属性（attribute） |     字段（field）      |

* 实现技术对比表

  | 维度         | Hibernate                 | Mybatis(ibatis)           |
  | ------------ | ------------------------- | ------------------------- |
  | 简单对比     | 强大，复杂，间接，SQL无关 | 小巧，简单，直接，SQL相关 |
  | 可移植性     | 好（不关心具体数据库）    | 差（根据数据库SQL编写）   |
  | 复杂多表关联 | 不支持                    | 支持                      |

### 2.8 物联网分层架构

![image-20230912225950686](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122259901.png)![image-20230912230134217](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122301710.png)

### 2.9 大数据分层架构

![image-20230912230330035](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122303318.png)

## 3、面向服务的软件架构风格【SOA】(❤❤❤❤)

* 服务是一种为了满足某项业务需求的操作、规则等逻辑组合，它包含一系列有序活动的交互，为实现用户目标提供支持

  ![image-20230912230548327](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122305679.png)

* 服务构建粗粒度，传统构建细粒度

* 服务构建的接口是标准的，主要是WSDL接口，传统构件常以具体API形式出现

* 服务构建的视线与语言无关，传统构建绑定某种特定语言

* 服务构建可以通过构建容器提供QoS的服务，传统构建完全由程序代码直接控制

  ![image-20230912230825826](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122308029.png)

### 3.1 Web Service【WEB服务】

![image-20230912231518948](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122315067.png)

* WSDL就是WebService对应的WSDL文件，该文件通过xml格式说明如何调用，可以看做WebService的接口文档【使用说明书】

### 3.2 REST【表述性状态转移】

* REST（Representational State Transfer）是一种通常使用HTTP和XML进行基于Web通信的技术，可以降低开发的复杂性，提高系统的可伸缩性

![image-20230912231939786](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122319909.png)

* REST的5个原则
  * 网络上的所有事物都被抽象为资源
  * 每个资源对应一个唯一的资源标识
  * 通过通用的连接件接口对资源进行操作
  * 对资源的各种操作不会改变资源标识
  * 所有的操作都是无状态的

### 3.3 ESB【企业服务总线】

![image-20230912232321556](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122323912.png)

* 提供位置透明性的消息路由和寻址服务
* 提供服务注册和命名的管理功能
* 支持多种的消息传递类型
* 支持多种可以广泛使用的传输协议
* 支持多种数据格式及其相互转换
* 提供过日志和监控功能

### 3.4 微服务

* 顾名思义，就是很小的服务，所以它属于面向服务架构的一种

![image-20230912232637103](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122326368.png)

* 微服务的优点解读

  | 优点           | 解读                                                         |
  | -------------- | ------------------------------------------------------------ |
  | 复杂应用解耦   | 小服务(且专注于做一件事情) <br/>化整为零，易于小团队开发     |
  | 独立           | 独立开发<br/>独立测试及独立部署（简单部署）<br>独立运行（每个服务独立在其独立进程中） |
  | 技术选型灵活   | 支持异构（如：每个服务使用不同数据库）                       |
  | 容错           | 故障被隔离在单个服务中，通过重试、平稳退化等机制实现应用层容错 |
  | 松耦合、易扩展 | 可根据需求独立扩展                                           |

* 面临问题与挑战
  * 分布式环境下的数据一致性【更复杂】
  * 测试的复杂性【服务间依赖测试】
  * 运维的复杂性

* 微服务架构模式方案

  ![image-20230912233448845](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122334991.png)

* 微服务与SOA

  * 微服务与SOA更精细，可以独立进程方式存在
  * 微服务接口更通用化，如用HTTP RESTful，各种终端都可调用，语言无关，平台无关
  * 更倾向于分布式部署，互联网场景更适合

### 3.5 云计算的概念/优点/分类

* 【云计算】是集合了大量计算设备和资源，对用户屏蔽底层差异的分布式处理架构，其用户与提供实际服务的计算资源是相分离的
* 【云计算优点】超大规模，虚拟化，高可靠性，高伸缩性，按需服务，成本低【前期投入低，综合使用成本也低】
* 按服务类型分类
  * Saas【软件及服务】：基于多租户技术实现，直接提供应用程序
  * Paas【平台即服务】：虚拟中间件服务器、运行环境和操作系统
  * Iaas【基础设施即服务】：包括服务器、存储和网络等服务

* 按部署方式分类
  * 公有云：面向互联网用户需求，通过开放网络提供云计算服务
  * 私有云：面向企业内部提供云计算服务
  * 混合云：兼顾以上两种情况的云计算服务

### 3.6 云计算的架构

![image-20230912235352616](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122353741.png)

* 管理层：提供对所有层次云计算服务的管理功能
* 用户访问层：方便用户使用云计算服务所需的各种支撑服务，针对每个层次的云计算服务都需要提供相应的访问接口
* 应用层：提供软件服务，如：财务管理，客户关系管理，商业智能
* 平台层：为用户提供对资源层服务的封装，使用户可以构建自己的应用
* 资源层：提供虚拟化的资源，从而隐藏物理资源的复杂性。如：服务器，存储

## 4、云原生架构风格(❤❤❤❤)

![image-20230912235945453](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309122359710.png)

* 【云原生】是基于分布部署和统一运管的分布式云，以容器、微服务、DevOps等技术为基础建立的一套云技术产品体系
* 本质：Oncloud → Incloud

### 4.1 云原生架构设计原则

* 服务化原则：使用微服务
* 弹性原则：可根据业务变化自动伸缩
* 可观测原则：通过日志、链路跟踪和度量
* 韧性原则：面对异常的抵御能力
* 所有过程自动化原则：自动化交付工具
* 零信任原则：默认不信任网络内部和外部的任何人/设备/系统
* 架构持续演进原则：业务高速迭代情况下的架构与业务平衡

### 4.2 云原生架构模式

* 服务化架构模式：典型代表【微服务】，服务拆分是维护压力大增
* Mesh化架构模式：把中间件框架（RPC、缓存、异步消息）从业务进程中分离，由Mesh进程完成。
* Serverless模式：非常适合于事件驱动的数据计算任务
* 存储计算分离模式：各类暂态数据（如session）用云服务保存
* 分布式事务模式：解决微服务模式中多数据源事务问题
* 可观测架构：包括Logging、Tracing、Metrics三个方面
* 时间驱动架构：本质上是一种应用/组件间的集成架构模式

### 4.3 云原生架构反模式

* 庞大的单体应用
  * 需要多人开发的业务模块，考虑通过服务化进行拆分，并让组织与架构匹配
* 单体应用“硬拆”为微服务（服务拆分要适度）
  * 小规模软件的服务拆分（为拆而拆）、数据依赖（服务间数据依赖）、性能降低
* 缺乏自动化能力的微服务
  * 手动维护大量微服务是不现实的

### 4.4 微服务的设计约束

* 微服务个体约束
  * 每个微服务都是独立的，修改一个微服务不能影响另一个微服务
* 微服务与微服务之间的横向关系
  * 通过第三服务注册中心线来满足服务的可发现性
* 微服务与数据层之间的纵向约束
  * 数据是微服务的“私产”，访问时需要通过微服务
* 全局视角下的微服务分布式约束
  * 高效运维整个系统

### 4.5 云原生

![image-20230913223102060](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132231169.png)![image-20230913223119207](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132231275.png)

### 4.6 边缘计算

* 【边缘计算】是指在靠近物或数据源头的一侧，采用网络、计算、存储、应用核心能力为一体的开放平台，就近提供最近端服务
* 【边缘计算的本质】计算处理职能的本地化

![image-20230913223540902](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132235046.png)![image-20230913223725743](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132237900.png)

## 5、质量属性与架构评估(❤❤❤❤❤)

![image-20230913224725753](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132247867.png)![image-20230913224742430](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132247622.png)![image-20230913224812163](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132248494.png)

## 6、 大型网站系统架构演化

![image-20230913224850537](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132248653.png)![image-20230913224944960](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132249132.png)

### 6.1 第一阶段：单体架构 到 第二阶段：垂直架构

![image-20230913225135926](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132251027.png)

### 6.2 第三阶段：使用缓存改善网站性能

![image-20230913231652696](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132316891.png)

* 常见缓存技术
  * MemCache：Memcache是一个高性能的分布式的内存对象缓存系统，用于动态Web应用以减轻数据库负载。Memcache通过内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果
  * Redis：是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API
  * Squid：Squid是一个高性能代理缓存服务器，Squid支持FTP、gopher、HTTPS和HTTP协议

* 缓存与数据库的数据的一致性问题

  * 数据读取

    * 根据key从缓存读取
    * 若缓存中没有，则根据key在数据库中查找
    * 读取到“值”之后，更新缓存

    ![](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132322115.png)

  * 数据写入（没有统一做法）

    * 根据key值写数据库

    * 根据key更新缓存

      ![image-20230913232407578](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132324747.png)

* 缓存技术对比【MemCache与Redis】

  | 工作       | MemCache                  | Redis                               |
  | ---------- | ------------------------- | ----------------------------------- |
  | 数据类型   | 简单key/value             | 丰富的数据结构                      |
  | 持久化     | 不支持                    | 支持                                |
  | 分布式存储 | 客户端哈希分片/一致性哈希 | 多种方式，主从、Sentinel、Cluster等 |
  | 多线程支持 | 支持                      | 支持（Redis5.0及以前版本不支持）    |
  | 内存管理   | 私有内存池/内存池         | 无                                  |
  | 事务支持   | 不支持                    | 有限支持                            |
  | 数据容灾   | 不支持，不能做数据恢复    | 支持，可以在灾难发生时，恢复数据    |

### 6.3 Redis分布式存储方案

| 分布式存储方案           | 核心特点                                               |
| ------------------------ | ------------------------------------------------------ |
| 主从（Master/Slave）模式 | 一主多从，故障时手动切换                               |
| 哨兵（Sentinel）模式     | 有哨兵的一主多从，主节点故障自动选择新的主节点         |
| 集群（Cluster）模式      | 分界点对等集群，分slots，不同slots的信息存储到不同节点 |

![image-20230913233142946](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132331119.png)

### 6.4 Redis 集群切片的常见方式

| 集群切片方式         | 核心特点                                                     |
| -------------------- | ------------------------------------------------------------ |
| 客户端分片           | 在客户端通过key的hash值对应到不同的服务器                    |
| 中间件实现分片       | 在应用软件和Redis中间，例如：Twemproxy、Codis等，由中间件实现服务到后台Redis节点的路由分派 |
| 客户端服务端协作分片 | Redis Cluster模式，客户端可采用一致性哈希，服务端提供错误节点的重定向服务slot。不同的slot对应到不同服务器 |

![image-20230913233451314](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132334503.png)

### 6.5 Redis 数据分片方案

| 分片方案       | 分片方式                  | 说明                                                         |
| -------------- | ------------------------- | ------------------------------------------------------------ |
| 范围分片       | 按数据范围值来做分片      | 例：按用户编号分片，0-999999映射到实例A；1000000-1999999映射到实例B |
| 哈希分片       | 通过对key进行hash运算分片 | 可以把数据分配到不同实例，这类似于取余操作，余数相同的，放在一个实例上 |
| 一致性哈希分片 | 哈希分片的改进            | 利于扩展节点，可以有效解决重新分配节点带来的无法命中问题     |

![image-20230913233945057](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132339254.png)![image-20230913234215049](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309132342244.png)

### 6.5 Redis数据类型

| 类型                           | 特点                                                         | 示例                                              |
| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------- |
| String(字符串)                 | 存储二进制，任何类型数据，最大512MB                          | 缓存，计数，共享Session                           |
| Hash（字典）                   | 无需字典，数组+链表，适合存对象；key对应一个HashMap。针对一组数据 | 存储、读取、修改用户属性                          |
| List（列表）                   | Linked List：双向链表，有序，增删快，查询慢；ArrayList：数组方式，有序，增删慢，查询快 | 消息队列，文章列表，记录前N个最新登录用户的ID列表 |
| Set（集合）                    | 键值对无序，唯一；增删查复杂度均为O(1)，支持交、并、差集操作 | 独立IP，共同爱好，标签                            |
| Sorted Set【Zset】（有序集合） | 键值对有序，唯一，自带按权重排序效果                         | 排行榜                                            |

### 6.6 Redis数据淘汰算法

| 淘汰作用范围         | 机制名          | 策略                                                         |
| -------------------- | --------------- | ------------------------------------------------------------ |
| 不淘汰               | noeviction      | 禁止驱逐数据，内存不足以容纳新入数据时，新写入操作就会报错。系统默认的一种淘汰策略 |
| 设置过期时间的键空间 | volatile-random | 随机移除某个key                                              |
| 设置过期时间的键空间 | volatile-lru    | 优先移除最近未使用的key【局部性原理】                        |
| 设置过期时间的键空间 | volatile-ttl    | ttl值小的key优先移除                                         |
| 全键空间             | allkeys-random  | 随机移除某个key                                              |
| 全键空间             | allkeys-lru     | 优先移除最近未使用的key                                      |

### 6.7 Redis的持久化

* Redis的持久化主要有两种方式：RDB和AOF
* RDB：传统数据库中快照的思想。指定时间间隔将数据进行快照的存储
* AOF：传统数据库中日志的思想，把每条改变数据集的命令追加到AOF的文件末尾，这样出问题了，可以重新执行AOF文件中的命令来重建数据集

| 对比维度     | RDB持久化                            | AOF持久化                              |
| ------------ | ------------------------------------ | -------------------------------------- |
| 备份量       | 重量级的全量备份，保存整个数据库     | 轻量级增量备份，一次只保存一个修改命令 |
| 保存间隔时间 | 保存间隔时间长                       | 保存间隔时间短，默认1秒                |
| 还原速度     | 数据还原速度快                       | 数据还原速度慢                         |
| 阻塞情况     | save会阻塞，但bgsave或者自动不会阻塞 | 无论平时还是AOF重写，都不会阻塞        |
| 数据体积     | 同等数据体积：小                     | 同等数据体积：大                       |
| 安全性       | 数据安全性：低，容易丢数据           | 数据安全性：高，根据策略决定           |

### 6.8 Redis常见问题

* 缓存雪崩

  ![image-20230914000213055](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309140002264.png)

  * 解决方案
    * 使用锁或队列：保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上
    * 为key设置不同的缓存失效时间：在固定的一个缓存时间的基础上+随机一个时间作为缓存失效时间
    * 二级缓存：设置一个有时间限制的缓存+一个无时间限制的缓存，避免大规模访问数据库

* 缓存穿透

  * 查询无数据返回->直接查数据库

  * 解决方案

    * 如果查询结果为空，直接设置一个默认值存放到缓存，这样第二次到缓存中获取就有值了。设置一个不超过5分钟的过期时间，以便能正常更新缓存
    * 设置布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力

    ![image-20230914001111032](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309140011218.png)

* 缓存预热
  * 系统上线后，将相关需要缓存数据直接加到缓存系统中
  * 解决方案
    * 直接写个缓存刷新页面，上线时手工操作
    * 数据量不大时，可以在项目启动的时候自动进行加载
    * 定时刷新缓存
* 缓存更新
  * 除Redis系统自带的缓存失效策略，常见采用以下两种
    * 定时清理过期的缓存
    * 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存
* 缓存降级
  * 降级的目的是保证核心服务可用，即使是有损的，而且有些服务是无法降级的（如电商的购物流程等）
  * 在进行降级之前要对系统进行梳理，从而梳理出哪些必须保护，哪些可降级

### 6.9 第四阶段：使用服务集群改善网站并发处理能力

![image-20230914001703014](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309140017236.png)

* 系统演变到这里，将会出现下面几个问题

  * 用户的请求由谁来转发到具体的应用服务器
  * 用户如果每次访问到的服务器不一样，那么如何维护session的一致性
    * 负载均衡
    * 有状态与无状态问题

  ![image-20230914234636454](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309142346627.png)

###  6.10 负载均衡

* 负载均衡的技术

  ![image-20230914234849546](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309142348818.png)

* 应用层负载均衡
  * http重定向。HTTP重定向就是应用层的请求转发。用户的请求其实已经到了HTTP重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群
    * 特点：实现简单，但性能较差
  * 反向代理服务器。在用户的请求到达反向代理服务器时（已经到达网站机房），由反向代理服务器根据算法转发到具体的服务器。常用的apache、nginx都可以充当反向代理服务器
    * 特点：部署简单，但代理服务器可能成为性能的瓶颈
* 传输层负载均衡
  * DNS域名解析负载均衡。DNS域名解析负载均衡就是在用户请求DNS服务器，获取域名对应的IP地址时，DNS服务器直接给出负载均衡后的服务器IP
    * 特点：域名BIHTTP重定向高，减少维护负载均衡服务器成本。但一个应用服务器故障，不能及时通知DNS，而且DNS负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理
  * 基于NAT的负载均衡。基于NAT的负载均衡将一个外部IP地址映射为多个IP地址，对每次连接请求动态地转换位一个内部节点的地址
    * 特点：技术较为成熟，一般在网关位置，可以通过硬件实现。项四层交换机一般就采用这种技术
* 静态算法（不考虑动态负载）
  * 轮换算法：轮流将服务请求（任务）调度给不同的节点（即：服务器）
  * 加权轮换算法：考虑不同节点处理能力的差异
  * 源地址哈希散列算法：根据请求的源IP地址，作为散列键从静态分配的散列表找出对应的节点
  * 目标地址哈希散列算法：根据请求目标IP做散列找出对应节点
  * 随机 算法：随机分配，简单，但不可控
* 动态算法（考虑动态负载）
  * 最小连接数算法：新请求分配给当前活动请求数量最少得节点，每个节点处理能力相同的情况下
  * 加权最小连接数算法：考虑节点处理能力不同，按最小连接数分配
  * 加全百分比算法：考虑了节点的利用率、硬盘速率、进程个数等，使用利用率来表现剩余处理能力
* 硬件负载均衡：F5
* 软件负载均衡：LVS，Nginx，HAproxy

### 6.11 有状态与无状态

* 无状态（stateless service）对单次请求的处理，不依赖其他请求，也就是说，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（比如说数据库），服务器本身不存储任何信息

* 有状态服务（stateful service）则相反，它会在自身保存一些数据，先后的请求是有关联的

* 判断一下构件是有状态服务还是无状态服务

  ![image-20230915001007947](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150010191.png)

* Session共享机制

  ![image-20230915001041367](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150010597.png)

### 6.12 第五阶段：数据库的读写分离

![image-20230915001337748](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150013970.png)

* 主从数据库结构特点
  * 一般：一主多从，也可以多主多从
  * 主库做写操作，从库做读操作
* 主从复制步骤
  * 主库（Master）更新数据完成前，将操作写binlog日志文件
  * 从库（Salve）打开I/O线程与主库连接，做binlog dump process，并将时间写入中继日志
  * 从库执行中继日志，保持与主库一致

### 6.13 用缓存缓解读库的压力

![image-20230915001813485](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150018577.png)

### 6.14 第六阶段：使用反向代理和CDN加速网站响应

![image-20230915001859664](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150018849.png)

* CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定

  ![image-20230915002109288](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150021519.png)

### 6.15 第七阶段：使用分布式文件系统和分布式数据库系统

![image-20230915002327339](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150023469.png)

### 6.16 第八阶段：使用NoSQL和搜索引擎

![image-20230915002530175](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150025373.png)

### 6.17 第九阶段：业务拆分

![image-20230915002620849](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150026032.png)

### 6.18 第十阶段：分布式服务

![image-20230915002720958](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150027303.png)

## 7、Web架构综合考查(❤❤❤❤❤)

### 7.1 WEB应用服务器

* WEB应用服务器可以理解为两层意思
  * WEB服务器：其职能较为单一，就是把浏览器发过来的Request请求，返回Html页面
  * 应用服务器：进行业务逻辑的处理

![image-20230915002913137](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150029353.png)

### 7.2 响应式Web设计

* 响应式WEB设计师一种网络页面设计布局，其理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境进行相对应的布局
* 方法与策略
  * 采用流式布局和弹性化设计：使用相对单位，设定百分比而非具体值的方式设置页面元素的大小
  * 响应式图片：不仅要同比的缩放图片，还要在小设备上降低图片自身的分辨率

## 8、关于中台

* "中台" 是一个在企业和技术领域中常用的术语，它通常指的是一种技术和组织结构的战略，用于提高企业的效率、灵活性和创新能力。中台的主要思想是将某些核心资源和能力集中在一个中间层，以便更好地满足业务需求和技术发展

![image-20230915003807608](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150038868.png)![image-20230915003850627](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150038856.png)

* 业务中台：提供重用服务，例如学员中心、课程中心之类的开箱即用可重用能力
* 数据中台：提供数据整合分析能力，帮助企业从数据中学习改进，调整方向
* 技术中台：提供技术重用组件能力，帮助解决基础技术平台的复用。如：中间件，分布式存储，AI，负载均衡等基础设施

![image-20230915004231798](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150042033.png)

* 数据中台必备的4个核心能力
  * 数据汇聚整合能力
  * 数据提纯加工能力
  * 数据服务可视化
  * 价值变现方面

### 9、常见架构分析

![image-20230915004449500](https://smcjava.oss-cn-hangzhou.aliyuncs.com/java/202309150044766.png)
